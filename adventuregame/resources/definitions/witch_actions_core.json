[
  {
    "type_name": "open",
    "lark": "open: OPEN thing\nOPEN.1: \"open\" WS",
    "pddl": "(:action OPEN\n    :parameters (?e - openable ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (closed ?e)\n        )\n    :effect (and\n        (open ?e)\n        (not (closed ?e))\n        (forall (?c - takeable)\n            (when\n                (in ?c ?e)\n                (and\n                    (accessible ?c)\n                )\n            )\n        )\n    )\n)",
    "pddl_parameter_mapping": {
      "?e": ["arg1"],
      "?r": ["current_player_room"],
      "?p": ["player"]
    },
    "failure_feedback": {
      "parameters": [
        ["{{ e }} is not openable.", "domain_trait_type_mismatch"],
        ["{{ r }} is not a room. (This should not occur.)", "domain_type_discrepancy"],
        ["{{ p }} is not a player. (This should not occur.)", "domain_type_discrepancy"]
      ],
      "precondition": [
        ["You are not where you are! (This should not occur.)", "world_state_discrepancy"],
        ["You can't see a {{ e }} here.", "entity_not_accessible"],
        ["The {{ e }} is not closed.", "entity_state_mismatch"]
      ]
    },
    "success_feedback": "The {{ e }} is now open. {{ container_content }}",
    "asp": "{ action_t(TURN,open,THING):at_t(TURN,THING,ROOM),closed_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nopen_t(TURN+1,THING) :- action_t(TURN,open,THING).\nopen_t(TURN+1,THING) :- turn(TURN), open_t(TURN,THING), not action_t(TURN,close,THING).",
    "epistemic": true,
    "pragmatic": true,
    "explanation": "To VERB is to make something physically unobstructed and uncovered, and make its contents available for use or interaction."
  },
  {
    "type_name": "close",
    "lark": "close: CLOSE thing\nCLOSE.1: \"close\" WS",
    "pddl": "(:action CLOSE\n    :parameters (?e - openable ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (open ?e)\n        )\n    :effect (and\n        (closed ?e)\n        (not (open ?e))\n        (forall (?i - takeable)\n            (when\n                (in ?i ?e)\n                (and\n                    (not (accessible ?i))\n                )\n            )\n        )\n    )\n)",
    "pddl_parameter_mapping": {
      "?e": ["arg1"],
      "?r": ["current_player_room"],
      "?p": ["player"]
    },
    "failure_feedback": {
      "parameters": [
        ["{{ e }} is not openable.", "domain_trait_type_mismatch"],
        ["{{ r }} is not a room. (This should not occur.)", "domain_type_discrepancy"],
        ["{{ p }} is not a player. (This should not occur.)", "domain_type_discrepancy"]
      ],
      "precondition": [
        ["You are not where you are! (This should not occur.)", "world_state_discrepancy"],
        ["You can't see a {{ e }} here.", "entity_not_accessible"],
        ["The {{ e }} is not open.", "entity_state_mismatch"]
      ]
    },
    "success_feedback": "The {{ e }} is now closed.",
    "asp": "{ action_t(TURN,close,THING):at_t(TURN,THING,ROOM),open_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nclosed_t(TURN+1,THING) :- action_t(TURN,close,THING).\nclosed_t(TURN+1,THING) :- turn(TURN), closed_t(TURN,THING), not action_t(TURN,open,THING).",
    "epistemic": false,
    "pragmatic": false,
    "explanation": "To VERB is to remove or block an opening of something, and make its contents unavailable for use or interaction."
  },
  {
    "type_name": "take",
    "lark": "take: TAKE PREP* thing (PREP thing)*\nTAKE.1: (\"take\" | \"grab\" | \"pick\" | \"get\") WS",
    "pddl": "(:action TAKE\n    :parameters (?e - takeable ?s - receptacle ?p - player ?i - inventory ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (not (in ?e inventory))\n        (at ?s ?r)\n        (accessible ?e)\n        (< (itemcount ?i) 2)\n        (or\n            (and\n                (on ?e ?s)\n                (support ?s)\n                )\n            (and\n                (open ?s)\n                (container ?s)\n                (in ?e ?s)\n                )\n            )\n        )\n    :effect (and\n        (in ?e ?i)\n        (increase (itemcount ?i) 1)\n        (when\n            (and\n                (support ?s)\n                (on ?e ?s)\n                )\n            (not (on ?e ?s))\n            )\n        (when\n            (and\n                (container ?s)\n                (in ?e ?s)\n                )\n            (not (in ?e ?s))\n            )\n    )\n)",
    "pddl_parameter_mapping": {
      "?e": ["arg1"],
      "?s": ["arg2", "arg1_receptacle"],
      "?p": ["player"],
      "?i": ["inventory"],
      "?r": ["current_player_room"]
    },
    "failure_feedback": {
      "parameters": [
        ["{{ e }} is not takeable.", "domain_trait_type_mismatch"],
        ["{{ s }} is not a receptacle.", "domain_trait_type_mismatch"],
        ["{{ p }} is not a player. (This should not occur.)", "domain_type_discrepancy"],
        ["{{ i }} is not an inventory. (This should not occur.)", "domain_type_discrepancy"],
        ["{{ r }} is not a room. (This should not occur.)", "domain_type_discrepancy"]
      ],
      "precondition": [
        ["You are not where you are! (This should not occur.)", "world_state_discrepancy"],
        ["You can't see a {{ e }} here.", "entity_not_accessible"],
        ["The {{ e }} is already in your inventory.", "entity_already_inventory"],
        ["You can't see a {{ s }} here.", "entity_not_accessible"],
        ["You can't see a {{ e }} here.", "entity_not_accessible"],
        ["Your inventory can not hold more than two objects at the same time.", "inventory_limit_exceeded"],
        ["The {{ e }} is not on the {{ s }}.", "entity_state_mismatch"],
        ["The {{ s }} is not a support.", "entity_trait_mismatch"],
        ["The {{ s }} is not open.", "entity_state_mismatch"],
        ["The {{ s }} is not a container.", "entity_trait_mismatch"],
        ["The {{ e }} is not in the {{ s }}.", "entity_state_mismatch"]
      ]
    },
    "success_feedback": "You take the {{ e }}. {{ inventory_desc }}",
    "asp": "{ action_t(TURN,take,THING):at_t(TURN,THING,ROOM),takeable(THING),in_t(TURN,THING,CONTAINER),open_t(TURN,CONTAINER),at_t(TURN,player1,ROOM);action_t(TURN,take,THING):at_t(TURN,THING,ROOM),takeable(THING),on_t(TURN,THING,SUPPORT),support(SUPPORT),at_t(TURN,player1,ROOM) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nin_t(TURN+1,THING,inventory) :- action_t(TURN,take,THING).\nin_t(TURN+1,THING,TARGET) :- turn(TURN), in_t(TURN,THING,TARGET), not action_t(TURN,take,THING), TARGET != inventory.\non_t(TURN+1,THING,TARGET) :- turn(TURN), on_t(TURN,THING,TARGET), not action_t(TURN,take,THING).",
    "epistemic": false,
    "pragmatic": true,
    "explanation": "To VERB is to get something into one's hands, possession or control."
  },
  {
    "type_name": "put",
    "lark": "put: PUT thing (\"back\" WS)* PREP* thing\nPUT.1: (\"put\" | \"leave\" | \"place\") WS",
    "pddl": "(:action PUT\n    :parameters (?e - movable ?t - receptacle ?p - player ?i - inventory ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (at ?t ?r)\n        (or\n            (and\n                (container ?t)\n                (not (closed ?t))\n                )\n            (support ?t)\n            )\n        )\n    :effect (and\n        (when\n            (in ?e ?i)\n            (decrease (itemcount ?i) 1)\n            )\n        (not (in ?e ?i))\n        (when\n            (support ?t)\n            (on ?e ?t)\n            )\n        (when\n            (container ?t)\n            (in ?e ?t)\n            )\n        )\n)",
    "pddl_parameter_mapping": {
      "?e": ["arg1"],
      "?t": ["arg2"],
      "?p": ["player"],
      "?i": ["inventory"],
      "?r": ["current_player_room"]
    },
    "failure_feedback": {
      "parameters": [
        ["{{ e }} is not moveable.", "domain_trait_type_mismatch"],
        ["{{ t }} is not a receptacle.", "domain_trait_type_mismatch"],
        ["{{ p }} is not a player. (This should not occur.)", "domain_type_discrepancy"],
        ["{{ i }} is not an inventory. (This should not occur.)", "domain_type_discrepancy"],
        ["{{ r }} is not a room. (This should not occur.)", "domain_type_discrepancy"]
      ],
      "precondition": [
        ["You are not where you are! (This should not occur.)", "world_state_discrepancy"],
        ["You can't see a {{ e }} here.", "entity_not_accessible"],
        ["You can't see a {{ t }} here.", "entity_not_accessible"],
        ["The {{ t }} is not a container.", "entity_trait_mismatch"],
        ["The {{ t }} is closed.", "entity_state_mismatch"],
        ["The {{ t }} is not a support.", "entity_trait_mismatch"]
      ]
    },
    "success_feedback": "You put the {{ e }} {{ prep }} the {{ t }}.",
    "asp": "{ action_t(TURN,put,THING,TARGET):at_t(TURN,THING,ROOM),at_t(TURN,player1,ROOM),at_t(TURN,TARGET,ROOM),at_t(TURN,SOURCE,ROOM),movable(THING),container(SOURCE),in_t(TURN,THING,SOURCE),open_t(TURN,SOURCE),container(TARGET),open_t(TURN,TARGET);\naction_t(TURN,put,THING,TARGET):at_t(TURN,THING,ROOM),at_t(TURN,player1,ROOM),at_t(TURN,TARGET,ROOM),at_t(TURN,SOURCE,ROOM),movable(THING),container(SOURCE),in_t(TURN,THING,SOURCE),open_t(TURN,SOURCE),container(TARGET),not openable(TARGET);\naction_t(TURN,put,THING,TARGET):at_t(TURN,THING,ROOM),at_t(TURN,player1,ROOM),at_t(TURN,TARGET,ROOM),at_t(TURN,SOURCE,ROOM),movable(THING),container(SOURCE),in_t(TURN,THING,SOURCE),not openable(SOURCE),container(TARGET),open_t(TURN,TARGET);\naction_t(TURN,put,THING,TARGET):at_t(TURN,THING,ROOM),at_t(TURN,player1,ROOM),at_t(TURN,TARGET,ROOM),at_t(TURN,SOURCE,ROOM),movable(THING),container(SOURCE),in_t(TURN,THING,SOURCE),not openable(SOURCE),container(TARGET),not openable(TARGET);\naction_t(TURN,put,THING,TARGET):at_t(TURN,THING,ROOM),at_t(TURN,player1,ROOM),at_t(TURN,TARGET,ROOM),at_t(TURN,SOURCE,ROOM),movable(THING),container(SOURCE),in_t(TURN,THING,SOURCE),open_t(TURN,SOURCE),support(TARGET);\naction_t(TURN,put,THING,TARGET):at_t(TURN,THING,ROOM),at_t(TURN,player1,ROOM),at_t(TURN,TARGET,ROOM),at_t(TURN,SOURCE,ROOM),movable(THING),container(SOURCE),in_t(TURN,THING,SOURCE),not openable(SOURCE),support(TARGET);\naction_t(TURN,put,THING,TARGET):at_t(TURN,THING,ROOM),at_t(TURN,player1,ROOM),at_t(TURN,TARGET,ROOM),support(TARGET),movable(THING),on_t(TURN,THING,SOURCE),support(SOURCE);\naction_t(TURN,put,THING,TARGET):at_t(TURN,THING,ROOM),at_t(TURN,player1,ROOM),at_t(TURN,TARGET,ROOM),movable(THING),in_t(TURN,THING,inventory),container(TARGET),open_t(TURN,TARGET),openable(TARGET);\naction_t(TURN,put,THING,TARGET):at_t(TURN,THING,ROOM),at_t(TURN,player1,ROOM),at_t(TURN,TARGET,ROOM),movable(THING),in_t(TURN,THING,inventory),container(TARGET),not openable(TARGET);\naction_t(TURN,put,THING,TARGET):at_t(TURN,THING,ROOM),at_t(TURN,player1,ROOM),at_t(TURN,TARGET,ROOM),movable(THING),in_t(TURN,THING,inventory),support(TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nin_t(TURN+1,THING,TARGET) :- turn(TURN), action_t(TURN,put,THING,TARGET), container(TARGET).\non_t(TURN+1,THING,TARGET) :- turn(TURN), action_t(TURN,put,THING,TARGET), support(TARGET).\nin_t(TURN+1,THING,inventory) :- turn(TURN), in_t(TURN,THING,inventory), not action_t(TURN,put,THING,_).",
    "epistemic": false,
    "pragmatic": true,
    "explanation": "To VERB is to physically place something somewhere."
  },
  {
    "type_name": "go",
    "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
    "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player ?i - inventory)\n    :precondition (and\n        (at ?p ?c)\n        (not (at ?p ?d))\n        (exit ?c ?d)\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n        (forall (?e - takeable)\n            (when\n                (in ?e ?i)\n                (and\n                    (at ?e ?d)\n                    (not (at ?e ?c))\n                )\n            )\n        )\n    )\n)",
    "pddl_parameter_mapping": {
      "?c": ["current_player_room"],
      "?d": ["arg1"],
      "?p": ["player"],
      "?i": ["inventory"]
    },
    "failure_feedback": {
      "parameters": [
        ["{{ c }} is not a room.", "domain_trait_type_mismatch"],
        ["{{ d }} is not a room.", "domain_trait_type_mismatch"],
        ["{{ p }} is not a player. (This should not occur.)", "domain_type_discrepancy"],
        ["{{ i }} is not an inventory. (This should not occur.)", "domain_type_discrepancy"]
      ],
      "precondition": [
        ["You are not where you are! (This should not occur.)", "world_state_discrepancy"],
        ["You are already in the {{ d }}.", "going_to_current_room"],
        ["You can't go to a {{ d }} from here.", "no_exit_to"]
      ]
    },
    "success_feedback": "{{ room_desc }}",
    "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,TARGET) :- action_t(TURN,go,TARGET), in_t(TURN,THING,inventory).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not in_t(TURN,THING,inventory), not turn_limit(TURN), THING != player1.",
    "epistemic": true,
    "pragmatic": true,
    "explanation": "To VERB is to move through space, especially to a place."
  },
  {
    "type_name": "done",
    "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
    "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
    "pddl_parameter_mapping": {
      "?p": ["player"],
      "?r": ["current_player_room"]
    },
    "failure_feedback": {
      "parameters": [
        ["{{ p }} is not a player. (This should not occur.)", "domain_type_discrepancy"],
        ["{{ r }} is not a room. (This should not occur.)", "domain_type_discrepancy"]
      ],
      "precondition": [
        ["You are not where you are! (This should not occur.)", "world_state_discrepancy"]
      ]
    },
    "success_feedback": "You consider yourself done.",
    "asp": "",
    "epistemic": false,
    "pragmatic": true,
    "explanation": "To VERB is to end the game."
  },
  {
    "type_name": "examine",
    "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
    "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
    "pddl_parameter_mapping": {
      "?p": ["player"],
      "?r": ["current_player_room"],
      "?e": ["arg1"]
    },
    "failure_feedback": {
      "parameters": [
        ["{{ p }} is not a player. (This should not occur.)", "domain_type_discrepancy"],
        ["{{ r }} is not a room. (This should not occur.)", "domain_type_discrepancy"],
        ["{{ e }} is not an entity. (This should not occur.)", "domain_type_discrepancy"]
      ],
      "precondition": [
        ["You are not where you are! (This should not occur.)", "world_state_discrepancy"],
        ["You can't see a {{ e }} here.", "entity_not_accessible"],
        ["Your inventory is not an entity. (This should not occur.)", "world_state_discrepancy"],
        ["You can't see a {{ e }} here.", "entity_not_accessible"]
      ]
    },
    "success_feedback": "{{ arg1_desc }}",
    "asp": "",
    "epistemic": true,
    "pragmatic": false,
    "explanation": "To VERB is to observe or inspect carefully."
  },
  {
    "type_name": "look",
    "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
    "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
    "pddl_parameter_mapping": {
      "?p": ["player"],
      "?r": ["current_player_room"]
    },
    "failure_feedback": {
      "parameters": [
        ["{{ p }} is not a player. (This should not occur.)", "domain_type_discrepancy"],
        ["{{ r }} is not a room. (This should not occur.)", "domain_type_discrepancy"]
      ],
      "precondition": [
        ["You are not where you are! (This should not occur.)", "world_state_discrepancy"]
      ]
    },
    "success_feedback": "{{ room_desc }}",
    "asp": "",
    "epistemic": true,
    "pragmatic": false,
    "explanation": "To VERB is to inspect a room."
  },
  {
    "type_name": "drop",
    "lark": "drop: DROP thing (\"away\")*\nDROP.1: (\"leave\" | \"drop\" | \"discard\" | \"throw\") WS",
    "pddl": "(:action DROP\n    :parameters (?e - takeable ?p - player ?i - inventory ?r - room ?f - floor)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (in ?e ?i)\n        (at ?f ?r)\n        )\n    :effect (and\n        (not (in ?e ?i))\n        (on ?e ?f)\n        (decrease (itemcount ?i) 1)\n        )\n)",
    "pddl_parameter_mapping": {
      "?e": ["arg1"],
      "?p": ["player"],
      "?i": ["inventory"],
      "?r": ["current_player_room"],
      "?f": ["current_room_floor"]
    },
    "failure_feedback": {
      "parameters": [
        ["{{ e }} is not takeable.", "domain_trait_type_mismatch"],
        ["{{ p }} is not a player. (This should not occur.)", "domain_type_discrepancy"],
        ["{{ i }} is not an inventory. (This should not occur.)", "domain_type_discrepancy"],
        ["{{ r }} is not a room. (This should not occur.)", "domain_type_discrepancy"],
        ["{{ f }} is not a floor. (This should not occur.)", "domain_type_discrepancy"]
      ],
      "precondition": [
        ["You are not where you are! (This should not occur.)", "world_state_discrepancy"],
        ["You can't see a {{ e }} here.", "entity_not_accessible"],
        ["You don't have a {{ t }} in your inventory.", "entity_not_accessible"],
        ["There is no floor here! (This should not occur.)", "entity_trait_mismatch"]
      ]
    },
    "success_feedback": "You drop the {{ e }} on the floor.",
    "asp": "{ action_t(TURN,put,THING,TARGET):at_t(TURN,THING,ROOM),at_t(TURN,player1,ROOM),at_t(TURN,TARGET,ROOM),at_t(TURN,SOURCE,ROOM),movable(THING),container(SOURCE),in_t(TURN,THING,SOURCE),open_t(TURN,SOURCE),container(TARGET),open_t(TURN,TARGET);\naction_t(TURN,put,THING,TARGET):at_t(TURN,THING,ROOM),at_t(TURN,player1,ROOM),at_t(TURN,TARGET,ROOM),at_t(TURN,SOURCE,ROOM),movable(THING),container(SOURCE),in_t(TURN,THING,SOURCE),open_t(TURN,SOURCE),container(TARGET),not openable(TARGET);\naction_t(TURN,put,THING,TARGET):at_t(TURN,THING,ROOM),at_t(TURN,player1,ROOM),at_t(TURN,TARGET,ROOM),at_t(TURN,SOURCE,ROOM),movable(THING),container(SOURCE),in_t(TURN,THING,SOURCE),not openable(SOURCE),container(TARGET),open_t(TURN,TARGET);\naction_t(TURN,put,THING,TARGET):at_t(TURN,THING,ROOM),at_t(TURN,player1,ROOM),at_t(TURN,TARGET,ROOM),at_t(TURN,SOURCE,ROOM),movable(THING),container(SOURCE),in_t(TURN,THING,SOURCE),not openable(SOURCE),container(TARGET),not openable(TARGET);\naction_t(TURN,put,THING,TARGET):at_t(TURN,THING,ROOM),at_t(TURN,player1,ROOM),at_t(TURN,TARGET,ROOM),at_t(TURN,SOURCE,ROOM),movable(THING),container(SOURCE),in_t(TURN,THING,SOURCE),open_t(TURN,SOURCE),support(TARGET);\naction_t(TURN,put,THING,TARGET):at_t(TURN,THING,ROOM),at_t(TURN,player1,ROOM),at_t(TURN,TARGET,ROOM),at_t(TURN,SOURCE,ROOM),movable(THING),container(SOURCE),in_t(TURN,THING,SOURCE),not openable(SOURCE),support(TARGET);\naction_t(TURN,put,THING,TARGET):at_t(TURN,THING,ROOM),at_t(TURN,player1,ROOM),at_t(TURN,TARGET,ROOM),support(TARGET),movable(THING),on_t(TURN,THING,SOURCE),support(SOURCE);\naction_t(TURN,put,THING,TARGET):at_t(TURN,THING,ROOM),at_t(TURN,player1,ROOM),at_t(TURN,TARGET,ROOM),movable(THING),in_t(TURN,THING,inventory),container(TARGET),open_t(TURN,TARGET),openable(TARGET);\naction_t(TURN,put,THING,TARGET):at_t(TURN,THING,ROOM),at_t(TURN,player1,ROOM),at_t(TURN,TARGET,ROOM),movable(THING),in_t(TURN,THING,inventory),container(TARGET),not openable(TARGET);\naction_t(TURN,put,THING,TARGET):at_t(TURN,THING,ROOM),at_t(TURN,player1,ROOM),at_t(TURN,TARGET,ROOM),movable(THING),in_t(TURN,THING,inventory),support(TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nin_t(TURN+1,THING,TARGET) :- turn(TURN), action_t(TURN,put,THING,TARGET), container(TARGET).\non_t(TURN+1,THING,TARGET) :- turn(TURN), action_t(TURN,put,THING,TARGET), support(TARGET).\nin_t(TURN+1,THING,inventory) :- turn(TURN), in_t(TURN,THING,inventory), not action_t(TURN,put,THING,_).",
    "epistemic": false,
    "pragmatic": true,
    "explanation": "To VERB is to dispose or get rid of (something); to lose, to remove."
  },
  {
    "type_name": "read",
    "lark": "read: READ thing\nREAD.1: \"read\" WS",
    "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (accessible ?e)\n        (readable ?e)\n        )\n    :effect (and\n    )\n)",
    "pddl_parameter_mapping": {
      "?p": ["player"],
      "?r": ["current_player_room"],
      "?e": ["arg1"]
    },
    "failure_feedback": {
      "parameters": [
        ["{{ p }} is not a player. (This should not occur.)", "domain_type_discrepancy"],
        ["{{ r }} is not a room. (This should not occur.)", "domain_type_discrepancy"],
        ["{{ e }} is not an entity. (This should not occur.)", "domain_type_discrepancy"]
      ],
      "precondition": [
        ["You are not where you are! (This should not occur.)", "world_state_discrepancy"],
        ["You can't see a {{ e }} here.", "entity_not_accessible"],
        ["You can't see a {{ e }} here.", "entity_not_accessible"],
        ["You can't see any text on the {{ e }}.", "entity_not_readable"]
      ]
    },
    "success_feedback": "You read the {{ e }}:\n{{ arg1_text }}",
    "asp": "",
    "epistemic": true,
    "pragmatic": false,
    "explanation": "To VERB is to look at and interpret letters or other information that is written."
  },
  {
    "type_name": "dump",
    "lark": "dump: DUMP thing PREP* thing\nDUMP.1: (\"dump\" | \"pour\" | \"empty\" ) WS",
    "pddl": "(:action DUMP\n    :parameters (?b - bucket ?t - container ?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        (at ?b ?r)\n        (at ?t ?r)\n        )\n    :effect (and\n        (when\n            (type ?b plasmbucket)\n            (and\n                (type ectoplasm1 ectoplasm)\n                (at ectoplasm1 ?r)\n                (in ectoplasm1 ?t)\n                (accessible ectoplasm1)\n                )\n            )\n        (when\n            (type ?b waterbucket)\n            (and\n                (type water1 water)\n                (at water1 ?r)\n                (in water1 ?t)\n                (accessible water1)\n                )\n            )\n        )\n)",
    "pddl_parameter_mapping": {
      "?b": ["arg1"],
      "?t": ["arg2"],
      "?p": ["player"],
      "?r": ["current_player_room"]
    },
    "failure_feedback": {
      "parameters": [
        ["{{ b }} is not a bucket.", "domain_type_discrepancy"],
        ["{{ t }} is not a container.", "domain_trait_type_mismatch"],
        ["{{ p }} is not a player. (This should not occur.)", "domain_type_discrepancy"],
        ["{{ r }} is not a room. (This should not occur.)", "domain_type_discrepancy"]
      ],
      "precondition": [
        ["You are not where you are! (This should not occur.)", "world_state_discrepancy"],
        ["You can't see a {{ b }} here.", "entity_not_accessible"],
        ["You can't see a {{ t }} here.", "entity_not_accessible"]
      ]
    },
    "success_feedback": "You pour the contents of {{ b }} into the {{ t }}. The {{ b }} instantly refills itself.",
    "asp": "{ action_t(TURN,dump,THING,cauldron1):at_t(TURN,THING,ROOM),at_t(TURN,player1,ROOM),at_t(TURN,cauldron1,ROOM),bucket(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,water1,ROOM) :- turn(TURN), action_t(TURN,dump,THING,cauldron1), at_t(TURN,player1,ROOM), type(THING,waterbucket).\nat_t(TURN+1,ectoplasm1,ROOM) :- turn(TURN), action_t(TURN,dump,THING,cauldron1), at_t(TURN,player1,ROOM), type(THING,plasmbucket).\nat_t(TURN+1,water1,ROOM) :- turn(TURN), at_t(TURN,water1,ROOM).\nat_t(TURN+1,ectoplasm1,ROOM) :- turn(TURN), at_t(TURN,ectoplasm1,ROOM).\nin_t(TURN+1,water1,cauldron1) :- turn(TURN), action_t(TURN,dump,THING,cauldron1), type(THING,waterbucket).\nin_t(TURN+1,ectoplasm1,cauldron1) :- turn(TURN), action_t(TURN,dump,THING,cauldron1), type(THING,plasmbucket).\nin_t(TURN+1,water1,cauldron1) :- turn(TURN), in_t(TURN,water1,cauldron1).\nin_t(TURN+1,ectoplasm1,cauldron1) :- turn(TURN), in_t(TURN,ectoplams1,cauldron1).",
    "epistemic": false,
    "pragmatic": true,
    "explanation": "To VERB is to cause (liquid, or liquid-like substance) to flow in a stream, either out of a container or into it."
  },
  {
    "type_name": "wave",
    "lark": "wave: WAVE thing ((\"at\" | \"over\" | \"on\") WS)* thing\nWAVE.1: (\"wave\" | \"wiggle\" | \"swirl\" | \"use\" ) WS",
    "pddl": "(:action WAVE\n    :parameters (?w - wand ?t - container ?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        (at ?w ?r)\n        (at ?t ?r)\n        )\n    :effect (and\n        (when\n            (type ?w firewand)\n            (and\n                (not (cold ?t))\n                (hot ?t)\n                )\n            )\n        (when\n            (type ?w icewand)\n            (and\n                (not (hot ?t))\n                (cold ?t)\n                )\n            )\n        (when\n            (type ?w fairywand)\n            (glittery ?t)\n            )\n        (when\n            (type ?w zulpowand)\n            (zulponated ?t)\n            )\n        )\n)",
    "pddl_parameter_mapping": {
      "?w": ["arg1"],
      "?t": ["arg2"],
      "?p": ["player"],
      "?r": ["current_player_room"]
    },
    "failure_feedback": {
      "parameters": [
        ["{{ b }} is not a wand.", "domain_type_discrepancy"],
        ["{{ t }} is not a container.", "domain_trait_type_mismatch"],
        ["{{ p }} is not a player. (This should not occur.)", "domain_type_discrepancy"],
        ["{{ r }} is not a room. (This should not occur.)", "domain_type_discrepancy"]
      ],
      "precondition": [
        ["You are not where you are! (This should not occur.)", "world_state_discrepancy"],
        ["You can't see a {{ w }} here.", "entity_not_accessible"],
        ["You can't see a {{ t }} here.", "entity_not_accessible"]
      ]
    },
    "success_feedback": "You wave the {{ w }} at the {{ t }}.",
    "asp": "{ action_t(TURN,wave,WAND,cauldron1):at_t(TURN,cauldron1,ROOM),at_t(TURN,WAND,ROOM) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nhot_t(TURN+1,cauldron1) :- action_t(TURN,wave,WAND,cauldron1), type(WAND,firewand).\ncold_t(TURN+1,cauldron1) :- action_t(TURN,wave,WAND,cauldron1), type(WAND,icewand).\nglittery_t(TURN+1,cauldron1) :- action_t(TURN,wave,WAND,cauldron1), type(WAND,fairywand).\nzulponated_t(TURN+1,cauldron1) :- action_t(TURN,wave,WAND,cauldron1), type(WAND,zulpowand).\nhot_t(TURN+1,cauldron1) :- turn(TURN), hot_t(TURN,cauldron1), not action_t(TURN,wave,WAND,cauldron1), type(WAND,icewand).\ncold_t(TURN+1,cauldron1) :- turn(TURN), cold_t(TURN,cauldron1), not action_t(TURN,wave,WAND,cauldron1), type(WAND,firewand).\nglittery_t(TURN+1,cauldron1) :- turn(TURN), glittery_t(TURN,cauldron1).\nzulponated_t(TURN+1,cauldron1) :- turn(TURN), zulponated_t(TURN,cauldron1).",
    "epistemic": false,
    "pragmatic": true,
    "explanation": "To VERB is to cause (liquid, or liquid-like substance) to flow in a stream, either out of a container or into it."
  },
  {
    "type_name": "stir",
    "lark": "stir: STIR thing ((\"with\" | \"using\") WS)* thing\nSTIR.1: (\"stir\" | \"agitate\" | \"mix\" | \"blend\") WS",
    "pddl": "(:action STIR\n    :parameters (?s - stirrer ?l - liquid ?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        (at ?s ?r)\n        (at ?l ?r)\n        )\n    :effect (and\n        (when\n            (type ?s ladle)\n            (ladlestirred ?l)\n            )\n        (when\n            (type ?s whisk)\n            (whisked ?l)\n            )\n        (when\n            (type ?s spoon)\n            (spoonstirred ?l)\n            )\n        (when\n            (type ?s borpulus)\n            (borpulusstirred ?l)\n            )\n        )\n)",
    "pddl_parameter_mapping": {
      "?s": ["arg2"],
      "?l": ["arg1"],
      "?p": ["player"],
      "?r": ["current_player_room"]
    },
    "failure_feedback": {
      "parameters": [
        ["{{ s }} is not a stirrer.", "domain_type_discrepancy"],
        ["{{ l }} is not a liquid.", "domain_trait_type_mismatch"],
        ["{{ p }} is not a player. (This should not occur.)", "domain_type_discrepancy"],
        ["{{ r }} is not a room. (This should not occur.)", "domain_type_discrepancy"]
      ],
      "precondition": [
        ["You are not where you are! (This should not occur.)", "world_state_discrepancy"],
        ["You can't see a {{ s }} here.", "entity_not_accessible"],
        ["You can't see a {{ l }} here.", "entity_not_accessible"]
      ]
    },
    "success_feedback": "You stir the {{ l }} with the {{ s }}.",
    "asp": "{ action_t(TURN,stir,THING,STIRRER):at_t(TURN,THING,ROOM),at_t(TURN,STIRRER,ROOM),in_t(TURN,THING,cauldron1) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nladlestirred_t(TURN+1,THING) :- action_t(TURN,stir,THING,STIRRER), type(STIRRER,ladle).\nwhisked_t(TURN+1,THING) :- action_t(TURN,stir,THING,STIRRER), type(STIRRER,whisk).\nspoonstirred_t(TURN+1,THING) :- action_t(TURN,stir,THING,STIRRER), type(STIRRER,spoon).\nborpulusstirred_t(TURN+1,THING) :- action_t(TURN,stir,THING,STIRRER), type(STIRRER,borpulus).\nladlestirred_t(TURN+1,THING) :- turn(TURN), ladlestirred_t(TURN,THING), not action_t(TURN,stir,THING,STIRRER), type(STIRRER,whisk).\nladlestirred_t(TURN+1,THING) :- turn(TURN), ladlestirred_t(TURN,THING), not action_t(TURN,stir,THING,STIRRER), type(STIRRER,spoon).\nladlestirred_t(TURN+1,THING) :- turn(TURN), ladlestirred_t(TURN,THING), not action_t(TURN,stir,THING,STIRRER), type(STIRRER,borpulus).\nwhisked_t(TURN+1,THING) :- turn(TURN), whisked_t(TURN,THING), not action_t(TURN,stir,THING,STIRRER), type(STIRRER,ladle).\nwhisked_t(TURN+1,THING) :- turn(TURN), whisked_t(TURN,THING), not action_t(TURN,stir,THING,STIRRER), type(STIRRER,spoon).\nwhisked_t(TURN+1,THING) :- turn(TURN), whisked_t(TURN,THING), not action_t(TURN,stir,THING,STIRRER), type(STIRRER,borpulus).\nspoonstirred_t(TURN+1,THING) :- turn(TURN), spoonstirred_t(TURN,THING), not action_t(TURN,stir,THING,STIRRER), type(STIRRER,ladle).\nspoonstirred_t(TURN+1,THING) :- turn(TURN), spoonstirred_t(TURN,THING), not action_t(TURN,stir,THING,STIRRER), type(STIRRER,spoon).\nspoonstirred_t(TURN+1,THING) :- turn(TURN), spoonstirred_t(TURN,THING), not action_t(TURN,stir,THING,STIRRER), type(STIRRER,whisk).\nborpulusstirred_t(TURN+1,THING) :- turn(TURN), borpulusstirred_t(TURN,THING), not action_t(TURN,stir,THING,STIRRER), type(STIRRER,ladle).\nborpulusstirred_t(TURN+1,THING) :- turn(TURN), borpulusstirred_t(TURN,THING), not action_t(TURN,stir,THING,STIRRER), type(STIRRER,spoon).\nborpulusstirred_t(TURN+1,THING) :- turn(TURN), borpulusstirred_t(TURN,THING), not action_t(TURN,stir,THING,STIRRER), type(STIRRER,whisk).",
    "epistemic": false,
    "pragmatic": true,
    "explanation": "To VERB is to disturb the content of (a container) by passing an object through it."
  }
]