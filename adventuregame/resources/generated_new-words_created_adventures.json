{
  "hard": [
    {
      "adventure_type": "new-words_created",
      "goal": "Make the inat mateny, the diale unsust and the subst dented.",
      "initial_state": [
        "at(decte1,unree1)",
        "at(enticed1,iness1)",
        "at(inat1,cally1)",
        "at(pante1,cally1)",
        "at(eness1,cally1)",
        "at(mical1,cally1)",
        "at(sness1,cally1)",
        "at(diale1,uness1)",
        "at(scont1,unree1)",
        "at(subst1,cally1)",
        "at(player1,cally1)",
        "type(player1,player)",
        "type(subst1,subst)",
        "type(scont1,scont)",
        "type(diale1,diale)",
        "type(sness1,sness)",
        "type(mical1,mical)",
        "type(eness1,eness)",
        "type(pante1,pante)",
        "type(inat1,inat)",
        "type(enticed1,enticed)",
        "type(decte1,decte)",
        "room(unree1,unree)",
        "room(iness1,iness)",
        "room(uness1,uness)",
        "room(cally1,cally)",
        "unsust(enticed1)",
        "unsust(pante1)",
        "unsust(eness1)",
        "unsust(mical1)",
        "exper(sness1)",
        "exper(diale1)",
        "mateny(decte1)",
        "stord(sness1)",
        "aphoned(inat1)",
        "exit(unree1,iness1)",
        "exit(iness1,unree1)",
        "exit(uness1,iness1)",
        "exit(cally1,unree1)",
        "exit(unree1,cally1)",
        "exit(iness1,uness1)",
        "dented_able(subst1)",
        "dented_able(scont1)",
        "dented_able(diale1)",
        "dented_able(mical1)",
        "dented_able(inat1)",
        "dented_able(enticed1)",
        "unsust_able(diale1)",
        "unsust_able(sness1)",
        "unsust_able(mical1)",
        "unsust_able(eness1)",
        "unsust_able(pante1)",
        "unsust_able(enticed1)",
        "mateny_able(sness1)",
        "mateny_able(inat1)",
        "mateny_able(decte1)"
      ],
      "goal_state": [
        "dented(subst1)",
        "unsust(diale1)",
        "mateny(inat1)"
      ],
      "optimal_turns": 6,
      "optimal_solution": [
        [
          "mator",
          "subst1"
        ],
        [
          "proar",
          "inat1"
        ],
        [
          "go",
          "unree1"
        ],
        [
          "go",
          "iness1"
        ],
        [
          "go",
          "uness1"
        ],
        [
          "gatic",
          "diale1"
        ]
      ],
      "optimal_commands": [
        "mator subst",
        "proar inat",
        "go unree",
        "go iness",
        "go uness",
        "gatic diale"
      ],
      "action_definitions": [
        {
          "lark": "mator: MATOR thing\nMATOR.1: \"mator\" WS",
          "pddl": "(:action MATOR\n    :parameters (?e - dented_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (dented ?e)\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not dented-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now dented.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To mator is to make something dented_able dented.",
          "asp": "{ action_t(TURN,mator,THING):at_t(TURN,THING,ROOM),dented_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\ndented_t(TURN+1,THING) :- action_t(TURN,mator,THING).\ndented_t(TURN+1,THING) :- turn(TURN), dented_t(TURN,THING).",
          "type_name": "mator"
        },
        {
          "lark": "unbal: UNBAL thing\nUNBAL.1: \"unbal\" WS",
          "pddl": "(:action UNBAL\n    :parameters (?e - unsust_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (unsust ?e)\n        )\n    :effect (and\n        (exper ?e)\n        (not (unsust ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not unsust-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not unsust.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now exper.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To unbal is to make something unsust_able and unsust be exper.",
          "asp": "{ action_t(TURN,unbal,THING):at_t(TURN,THING,ROOM),unsust_able(THING),unsust_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nexper_t(TURN+1,THING) :- action_t(TURN,unbal,THING).\nunsust_t(TURN+1,THING) :- turn(TURN), unsust_t(TURN,THING), not action_t(TURN,unbal,THING).",
          "type_name": "unbal"
        },
        {
          "lark": "gatic: GATIC thing\nGATIC.1: \"gatic\" WS",
          "pddl": "(:action GATIC\n    :parameters (?e - unsust_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (exper ?e)\n        )\n    :effect (and\n        (unsust ?e)\n        (not (exper ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not unsust-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not exper.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now unsust.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To gatic is to make something unsust_able and exper be unsust.",
          "asp": "{ action_t(TURN,gatic,THING):at_t(TURN,THING,ROOM),unsust_able(THING),exper_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nunsust_t(TURN+1,THING) :- action_t(TURN,gatic,THING).\nexper_t(TURN+1,THING) :- turn(TURN), exper_t(TURN,THING), not action_t(TURN,gatic,THING).",
          "type_name": "gatic"
        },
        {
          "lark": "ratic: RATIC thing\nRATIC.1: \"ratic\" WS",
          "pddl": "(:action RATIC\n    :parameters (?e - mateny_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (mateny ?e)\n        )\n    :effect (and\n        (stord ?e)\n        (not (mateny ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not mateny-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not mateny.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now stord.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To ratic is to make something mateny_able and mateny be stord.",
          "asp": "{ action_t(TURN,ratic,THING):at_t(TURN,THING,ROOM),mateny_able(THING),mateny_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nstord_t(TURN+1,THING) :- action_t(TURN,ratic,THING).\nmateny_t(TURN+1,THING) :- turn(TURN), mateny_t(TURN,THING), not action_t(TURN,ratic,THING).",
          "type_name": "ratic"
        },
        {
          "lark": "remic: REMIC thing\nREMIC.1: \"remic\" WS",
          "pddl": "(:action REMIC\n    :parameters (?e - mateny_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (stord ?e)\n        )\n    :effect (and\n        (aphoned ?e)\n        (not (stord ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not mateny-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not stord.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now aphoned.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To remic is to make something mateny_able and stord be aphoned.",
          "asp": "{ action_t(TURN,remic,THING):at_t(TURN,THING,ROOM),mateny_able(THING),stord_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\naphoned_t(TURN+1,THING) :- action_t(TURN,remic,THING).\nstord_t(TURN+1,THING) :- turn(TURN), stord_t(TURN,THING), not action_t(TURN,remic,THING).",
          "type_name": "remic"
        },
        {
          "lark": "proar: PROAR thing\nPROAR.1: \"proar\" WS",
          "pddl": "(:action PROAR\n    :parameters (?e - mateny_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (aphoned ?e)\n        )\n    :effect (and\n        (mateny ?e)\n        (not (aphoned ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not mateny-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not aphoned.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now mateny.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To proar is to make something mateny_able and aphoned be mateny.",
          "asp": "{ action_t(TURN,proar,THING):at_t(TURN,THING,ROOM),mateny_able(THING),aphoned_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nmateny_t(TURN+1,THING) :- action_t(TURN,proar,THING).\naphoned_t(TURN+1,THING) :- turn(TURN), aphoned_t(TURN,THING), not action_t(TURN,proar,THING).",
          "type_name": "proar"
        },
        {
          "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
          "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
          "pddl_parameter_mapping": {
            "?c": [
              "current_player_room"
            ],
            "?d": [
              "arg1"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ c }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ d }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't go to a {{ d }} from here.",
                "no_exit_to"
              ],
              [
                "You are already in the {{ d }}.",
                "going_to_current_room"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
          "epistemic": true,
          "pragmatic": true,
          "explanation": "To VERB is to move through space, especially to a place.",
          "type_name": "go"
        },
        {
          "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
          "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "You consider yourself done.",
          "asp": "",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To VERB is to end the game.",
          "type_name": "done"
        },
        {
          "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ],
            "?e": [
              "arg1"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ e }} is not an entity. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "Your inventory is not an entity. (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "{{ arg1_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to observe or inspect carefully.",
          "type_name": "examine"
        },
        {
          "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to inspect a room.",
          "type_name": "look"
        }
      ],
      "room_definitions": [
        {
          "repr_str": "unree",
          "exit_targets": [
            "uness",
            "iness"
          ],
          "max_connections": 1,
          "type_name": "unree"
        },
        {
          "repr_str": "iness",
          "exit_targets": [
            "unree"
          ],
          "max_connections": 3,
          "type_name": "iness"
        },
        {
          "repr_str": "uness",
          "exit_targets": [
            "iness",
            "cally"
          ],
          "max_connections": 2,
          "type_name": "uness"
        },
        {
          "repr_str": "cally",
          "exit_targets": [
            "uness",
            "iness",
            "unree"
          ],
          "max_connections": 2,
          "type_name": "cally"
        }
      ],
      "entity_definitions": [
        {
          "repr_str": "subst",
          "traits": [
            "dented_able"
          ],
          "standard_locations": [
            "iness",
            "cally"
          ],
          "type_name": "subst"
        },
        {
          "repr_str": "scont",
          "traits": [
            "dented_able"
          ],
          "standard_locations": [
            "unree"
          ],
          "type_name": "scont"
        },
        {
          "repr_str": "diale",
          "traits": [
            "unsust_able",
            "dented_able"
          ],
          "standard_locations": [
            "cally",
            "uness"
          ],
          "type_name": "diale"
        },
        {
          "repr_str": "sness",
          "traits": [
            "unsust_able",
            "mateny_able"
          ],
          "standard_locations": [
            "cally"
          ],
          "type_name": "sness"
        },
        {
          "repr_str": "mical",
          "traits": [
            "unsust_able",
            "dented_able"
          ],
          "standard_locations": [
            "cally",
            "iness"
          ],
          "type_name": "mical"
        },
        {
          "repr_str": "eness",
          "traits": [
            "unsust_able"
          ],
          "standard_locations": [
            "unree",
            "cally"
          ],
          "type_name": "eness"
        },
        {
          "repr_str": "pante",
          "traits": [
            "unsust_able"
          ],
          "standard_locations": [
            "cally"
          ],
          "type_name": "pante"
        },
        {
          "repr_str": "inat",
          "traits": [
            "mateny_able",
            "dented_able"
          ],
          "standard_locations": [
            "cally"
          ],
          "type_name": "inat"
        },
        {
          "repr_str": "enticed",
          "traits": [
            "dented_able",
            "unsust_able"
          ],
          "standard_locations": [
            "iness"
          ],
          "type_name": "enticed"
        },
        {
          "repr_str": "decte",
          "traits": [
            "mateny_able"
          ],
          "standard_locations": [
            "unree",
            "uness"
          ],
          "type_name": "decte"
        },
        {
          "repr_str": "you",
          "traits": [],
          "hidden": true,
          "type_name": "player"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "inventory"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "floor"
        }
      ],
      "domain_definitions": [
        {
          "domain_id": "new_words",
          "types": {
            "room": [
              "unree",
              "iness",
              "uness",
              "cally"
            ],
            "entity": [
              "player",
              "inventory",
              "floor",
              "subst",
              "scont",
              "diale",
              "sness",
              "mical",
              "eness",
              "pante",
              "inat",
              "enticed",
              "decte",
              "player",
              "inventory",
              "floor"
            ],
            "dented_able": [
              "subst",
              "scont",
              "diale",
              "mical",
              "inat",
              "enticed"
            ],
            "unsust_able": [
              "diale",
              "sness",
              "mical",
              "eness",
              "pante",
              "enticed"
            ],
            "mateny_able": [
              "sness",
              "inat",
              "decte"
            ]
          },
          "predicates": [
            {
              "predicate_id": "dented",
              "variable": "e",
              "mutability": "dented_able"
            },
            {
              "predicate_id": "unsust",
              "variable": "e",
              "mutability": "unsust_able"
            },
            {
              "predicate_id": "exper",
              "variable": "e",
              "mutability": "unsust_able"
            },
            {
              "predicate_id": "mateny",
              "variable": "e",
              "mutability": "mateny_able"
            },
            {
              "predicate_id": "stord",
              "variable": "e",
              "mutability": "mateny_able"
            },
            {
              "predicate_id": "aphoned",
              "variable": "e",
              "mutability": "mateny_able"
            }
          ]
        }
      ],
      "bench_turn_limit": 50,
      "prompt_template_set": "new-words_created"
    },
    {
      "adventure_type": "new-words_created",
      "goal": "Make the secti unpish, the rably nolog and the imped atory.",
      "initial_state": [
        "at(nogia1,uner1)",
        "at(trionee1,natin1)",
        "at(rably1,perced1)",
        "at(stism1,perced1)",
        "at(torish1,perced1)",
        "at(inet1,perced1)",
        "at(nond1,perced1)",
        "at(imped1,trion1)",
        "at(trateler1,uner1)",
        "at(secti1,perced1)",
        "at(player1,perced1)",
        "type(player1,player)",
        "type(secti1,secti)",
        "type(trateler1,trateler)",
        "type(imped1,imped)",
        "type(nond1,nond)",
        "type(inet1,inet)",
        "type(torish1,torish)",
        "type(stism1,stism)",
        "type(rably1,rably)",
        "type(trionee1,trionee)",
        "type(nogia1,nogia)",
        "room(uner1,uner)",
        "room(natin1,natin)",
        "room(trion1,trion)",
        "room(perced1,perced)",
        "atory(trionee1)",
        "atory(stism1)",
        "atory(torish1)",
        "atory(inet1)",
        "aling(nond1)",
        "aling(imped1)",
        "nolog(nogia1)",
        "vater(nond1)",
        "atione(rably1)",
        "exit(uner1,natin1)",
        "exit(natin1,uner1)",
        "exit(trion1,natin1)",
        "exit(perced1,uner1)",
        "exit(uner1,perced1)",
        "exit(natin1,trion1)",
        "unpish_able(secti1)",
        "unpish_able(trateler1)",
        "unpish_able(imped1)",
        "unpish_able(inet1)",
        "unpish_able(rably1)",
        "unpish_able(trionee1)",
        "atory_able(imped1)",
        "atory_able(nond1)",
        "atory_able(inet1)",
        "atory_able(torish1)",
        "atory_able(stism1)",
        "atory_able(trionee1)",
        "nolog_able(nond1)",
        "nolog_able(rably1)",
        "nolog_able(nogia1)"
      ],
      "goal_state": [
        "unpish(secti1)",
        "atory(imped1)",
        "nolog(rably1)"
      ],
      "optimal_turns": 6,
      "optimal_solution": [
        [
          "ousne",
          "secti1"
        ],
        [
          "ceous",
          "rably1"
        ],
        [
          "go",
          "uner1"
        ],
        [
          "go",
          "natin1"
        ],
        [
          "go",
          "trion1"
        ],
        [
          "delly",
          "imped1"
        ]
      ],
      "optimal_commands": [
        "ousne secti",
        "ceous rably",
        "go uner",
        "go natin",
        "go trion",
        "delly imped"
      ],
      "action_definitions": [
        {
          "lark": "ousne: OUSNE thing\nOUSNE.1: \"ousne\" WS",
          "pddl": "(:action OUSNE\n    :parameters (?e - unpish_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (unpish ?e)\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not unpish-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now unpish.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To ousne is to make something unpish_able unpish.",
          "asp": "{ action_t(TURN,ousne,THING):at_t(TURN,THING,ROOM),unpish_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nunpish_t(TURN+1,THING) :- action_t(TURN,ousne,THING).\nunpish_t(TURN+1,THING) :- turn(TURN), unpish_t(TURN,THING).",
          "type_name": "ousne"
        },
        {
          "lark": "heted: HETED thing\nHETED.1: \"heted\" WS",
          "pddl": "(:action HETED\n    :parameters (?e - atory_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (atory ?e)\n        )\n    :effect (and\n        (aling ?e)\n        (not (atory ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not atory-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not atory.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now aling.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To heted is to make something atory_able and atory be aling.",
          "asp": "{ action_t(TURN,heted,THING):at_t(TURN,THING,ROOM),atory_able(THING),atory_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\naling_t(TURN+1,THING) :- action_t(TURN,heted,THING).\natory_t(TURN+1,THING) :- turn(TURN), atory_t(TURN,THING), not action_t(TURN,heted,THING).",
          "type_name": "heted"
        },
        {
          "lark": "delly: DELLY thing\nDELLY.1: \"delly\" WS",
          "pddl": "(:action DELLY\n    :parameters (?e - atory_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (aling ?e)\n        )\n    :effect (and\n        (atory ?e)\n        (not (aling ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not atory-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not aling.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now atory.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To delly is to make something atory_able and aling be atory.",
          "asp": "{ action_t(TURN,delly,THING):at_t(TURN,THING,ROOM),atory_able(THING),aling_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\natory_t(TURN+1,THING) :- action_t(TURN,delly,THING).\naling_t(TURN+1,THING) :- turn(TURN), aling_t(TURN,THING), not action_t(TURN,delly,THING).",
          "type_name": "delly"
        },
        {
          "lark": "unalin: UNALIN thing\nUNALIN.1: \"unalin\" WS",
          "pddl": "(:action UNALIN\n    :parameters (?e - nolog_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (nolog ?e)\n        )\n    :effect (and\n        (vater ?e)\n        (not (nolog ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not nolog-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not nolog.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now vater.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To unalin is to make something nolog_able and nolog be vater.",
          "asp": "{ action_t(TURN,unalin,THING):at_t(TURN,THING,ROOM),nolog_able(THING),nolog_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nvater_t(TURN+1,THING) :- action_t(TURN,unalin,THING).\nnolog_t(TURN+1,THING) :- turn(TURN), nolog_t(TURN,THING), not action_t(TURN,unalin,THING).",
          "type_name": "unalin"
        },
        {
          "lark": "thoty: THOTY thing\nTHOTY.1: \"thoty\" WS",
          "pddl": "(:action THOTY\n    :parameters (?e - nolog_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (vater ?e)\n        )\n    :effect (and\n        (atione ?e)\n        (not (vater ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not nolog-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not vater.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now atione.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To thoty is to make something nolog_able and vater be atione.",
          "asp": "{ action_t(TURN,thoty,THING):at_t(TURN,THING,ROOM),nolog_able(THING),vater_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\natione_t(TURN+1,THING) :- action_t(TURN,thoty,THING).\nvater_t(TURN+1,THING) :- turn(TURN), vater_t(TURN,THING), not action_t(TURN,thoty,THING).",
          "type_name": "thoty"
        },
        {
          "lark": "ceous: CEOUS thing\nCEOUS.1: \"ceous\" WS",
          "pddl": "(:action CEOUS\n    :parameters (?e - nolog_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (atione ?e)\n        )\n    :effect (and\n        (nolog ?e)\n        (not (atione ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not nolog-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not atione.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now nolog.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To ceous is to make something nolog_able and atione be nolog.",
          "asp": "{ action_t(TURN,ceous,THING):at_t(TURN,THING,ROOM),nolog_able(THING),atione_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nnolog_t(TURN+1,THING) :- action_t(TURN,ceous,THING).\natione_t(TURN+1,THING) :- turn(TURN), atione_t(TURN,THING), not action_t(TURN,ceous,THING).",
          "type_name": "ceous"
        },
        {
          "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
          "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
          "pddl_parameter_mapping": {
            "?c": [
              "current_player_room"
            ],
            "?d": [
              "arg1"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ c }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ d }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't go to a {{ d }} from here.",
                "no_exit_to"
              ],
              [
                "You are already in the {{ d }}.",
                "going_to_current_room"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
          "epistemic": true,
          "pragmatic": true,
          "explanation": "To VERB is to move through space, especially to a place.",
          "type_name": "go"
        },
        {
          "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
          "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "You consider yourself done.",
          "asp": "",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To VERB is to end the game.",
          "type_name": "done"
        },
        {
          "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ],
            "?e": [
              "arg1"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ e }} is not an entity. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "Your inventory is not an entity. (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "{{ arg1_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to observe or inspect carefully.",
          "type_name": "examine"
        },
        {
          "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to inspect a room.",
          "type_name": "look"
        }
      ],
      "room_definitions": [
        {
          "repr_str": "uner",
          "exit_targets": [
            "trion",
            "natin"
          ],
          "max_connections": 1,
          "type_name": "uner"
        },
        {
          "repr_str": "natin",
          "exit_targets": [
            "uner"
          ],
          "max_connections": 3,
          "type_name": "natin"
        },
        {
          "repr_str": "trion",
          "exit_targets": [
            "natin",
            "perced"
          ],
          "max_connections": 2,
          "type_name": "trion"
        },
        {
          "repr_str": "perced",
          "exit_targets": [
            "trion",
            "natin",
            "uner"
          ],
          "max_connections": 2,
          "type_name": "perced"
        }
      ],
      "entity_definitions": [
        {
          "repr_str": "secti",
          "traits": [
            "unpish_able"
          ],
          "standard_locations": [
            "natin",
            "perced"
          ],
          "type_name": "secti"
        },
        {
          "repr_str": "trateler",
          "traits": [
            "unpish_able"
          ],
          "standard_locations": [
            "uner"
          ],
          "type_name": "trateler"
        },
        {
          "repr_str": "imped",
          "traits": [
            "atory_able",
            "unpish_able"
          ],
          "standard_locations": [
            "perced",
            "trion"
          ],
          "type_name": "imped"
        },
        {
          "repr_str": "nond",
          "traits": [
            "atory_able",
            "nolog_able"
          ],
          "standard_locations": [
            "perced"
          ],
          "type_name": "nond"
        },
        {
          "repr_str": "inet",
          "traits": [
            "atory_able",
            "unpish_able"
          ],
          "standard_locations": [
            "perced",
            "natin"
          ],
          "type_name": "inet"
        },
        {
          "repr_str": "torish",
          "traits": [
            "atory_able"
          ],
          "standard_locations": [
            "uner",
            "perced"
          ],
          "type_name": "torish"
        },
        {
          "repr_str": "stism",
          "traits": [
            "atory_able"
          ],
          "standard_locations": [
            "perced"
          ],
          "type_name": "stism"
        },
        {
          "repr_str": "rably",
          "traits": [
            "nolog_able",
            "unpish_able"
          ],
          "standard_locations": [
            "perced"
          ],
          "type_name": "rably"
        },
        {
          "repr_str": "trionee",
          "traits": [
            "unpish_able",
            "atory_able"
          ],
          "standard_locations": [
            "natin"
          ],
          "type_name": "trionee"
        },
        {
          "repr_str": "nogia",
          "traits": [
            "nolog_able"
          ],
          "standard_locations": [
            "uner",
            "trion"
          ],
          "type_name": "nogia"
        },
        {
          "repr_str": "you",
          "traits": [],
          "hidden": true,
          "type_name": "player"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "inventory"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "floor"
        }
      ],
      "domain_definitions": [
        {
          "domain_id": "new_words",
          "types": {
            "room": [
              "uner",
              "natin",
              "trion",
              "perced"
            ],
            "entity": [
              "player",
              "inventory",
              "floor",
              "secti",
              "trateler",
              "imped",
              "nond",
              "inet",
              "torish",
              "stism",
              "rably",
              "trionee",
              "nogia",
              "player",
              "inventory",
              "floor"
            ],
            "unpish_able": [
              "secti",
              "trateler",
              "imped",
              "inet",
              "rably",
              "trionee"
            ],
            "atory_able": [
              "imped",
              "nond",
              "inet",
              "torish",
              "stism",
              "trionee"
            ],
            "nolog_able": [
              "nond",
              "rably",
              "nogia"
            ]
          },
          "predicates": [
            {
              "predicate_id": "unpish",
              "variable": "e",
              "mutability": "unpish_able"
            },
            {
              "predicate_id": "atory",
              "variable": "e",
              "mutability": "atory_able"
            },
            {
              "predicate_id": "aling",
              "variable": "e",
              "mutability": "atory_able"
            },
            {
              "predicate_id": "nolog",
              "variable": "e",
              "mutability": "nolog_able"
            },
            {
              "predicate_id": "vater",
              "variable": "e",
              "mutability": "nolog_able"
            },
            {
              "predicate_id": "atione",
              "variable": "e",
              "mutability": "nolog_able"
            }
          ]
        }
      ],
      "bench_turn_limit": 50,
      "prompt_template_set": "new-words_created"
    },
    {
      "adventure_type": "new-words_created",
      "goal": "Make the tulacy enerk, the menny soriced and the ortid alism.",
      "initial_state": [
        "at(reele1,penol1)",
        "at(inging1,micon1)",
        "at(menny1,catint1)",
        "at(rist1,catint1)",
        "at(sioust1,catint1)",
        "at(pacia1,catint1)",
        "at(unflued1,catint1)",
        "at(tulacy1,fress1)",
        "at(uncest1,penol1)",
        "at(ortid1,catint1)",
        "at(player1,catint1)",
        "type(player1,player)",
        "type(ortid1,ortid)",
        "type(uncest1,uncest)",
        "type(tulacy1,tulacy)",
        "type(unflued1,unflued)",
        "type(pacia1,pacia)",
        "type(sioust1,sioust)",
        "type(rist1,rist)",
        "type(menny1,menny)",
        "type(inging1,inging)",
        "type(reele1,reele)",
        "room(penol1,penol)",
        "room(micon1,micon)",
        "room(fress1,fress)",
        "room(catint1,catint)",
        "enerk(inging1)",
        "enerk(rist1)",
        "enerk(sioust1)",
        "enerk(pacia1)",
        "prustic(unflued1)",
        "prustic(tulacy1)",
        "soriced(reele1)",
        "logal(unflued1)",
        "ramiced(menny1)",
        "exit(penol1,micon1)",
        "exit(micon1,penol1)",
        "exit(fress1,micon1)",
        "exit(catint1,penol1)",
        "exit(penol1,catint1)",
        "exit(micon1,fress1)",
        "alism_able(ortid1)",
        "alism_able(uncest1)",
        "alism_able(tulacy1)",
        "alism_able(pacia1)",
        "alism_able(menny1)",
        "alism_able(inging1)",
        "enerk_able(tulacy1)",
        "enerk_able(unflued1)",
        "enerk_able(pacia1)",
        "enerk_able(sioust1)",
        "enerk_able(rist1)",
        "enerk_able(inging1)",
        "soriced_able(unflued1)",
        "soriced_able(menny1)",
        "soriced_able(reele1)"
      ],
      "goal_state": [
        "alism(ortid1)",
        "enerk(tulacy1)",
        "soriced(menny1)"
      ],
      "optimal_turns": 6,
      "optimal_solution": [
        [
          "sulphy",
          "ortid1"
        ],
        [
          "latory",
          "menny1"
        ],
        [
          "go",
          "penol1"
        ],
        [
          "go",
          "micon1"
        ],
        [
          "go",
          "fress1"
        ],
        [
          "tedne",
          "tulacy1"
        ]
      ],
      "optimal_commands": [
        "sulphy ortid",
        "latory menny",
        "go penol",
        "go micon",
        "go fress",
        "tedne tulacy"
      ],
      "action_definitions": [
        {
          "lark": "sulphy: SULPHY thing\nSULPHY.1: \"sulphy\" WS",
          "pddl": "(:action SULPHY\n    :parameters (?e - alism_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (alism ?e)\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not alism-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now alism.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To sulphy is to make something alism_able alism.",
          "asp": "{ action_t(TURN,sulphy,THING):at_t(TURN,THING,ROOM),alism_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nalism_t(TURN+1,THING) :- action_t(TURN,sulphy,THING).\nalism_t(TURN+1,THING) :- turn(TURN), alism_t(TURN,THING).",
          "type_name": "sulphy"
        },
        {
          "lark": "derman: DERMAN thing\nDERMAN.1: \"derman\" WS",
          "pddl": "(:action DERMAN\n    :parameters (?e - enerk_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (enerk ?e)\n        )\n    :effect (and\n        (prustic ?e)\n        (not (enerk ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not enerk-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not enerk.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now prustic.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To derman is to make something enerk_able and enerk be prustic.",
          "asp": "{ action_t(TURN,derman,THING):at_t(TURN,THING,ROOM),enerk_able(THING),enerk_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nprustic_t(TURN+1,THING) :- action_t(TURN,derman,THING).\nenerk_t(TURN+1,THING) :- turn(TURN), enerk_t(TURN,THING), not action_t(TURN,derman,THING).",
          "type_name": "derman"
        },
        {
          "lark": "tedne: TEDNE thing\nTEDNE.1: \"tedne\" WS",
          "pddl": "(:action TEDNE\n    :parameters (?e - enerk_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (prustic ?e)\n        )\n    :effect (and\n        (enerk ?e)\n        (not (prustic ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not enerk-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not prustic.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now enerk.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To tedne is to make something enerk_able and prustic be enerk.",
          "asp": "{ action_t(TURN,tedne,THING):at_t(TURN,THING,ROOM),enerk_able(THING),prustic_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nenerk_t(TURN+1,THING) :- action_t(TURN,tedne,THING).\nprustic_t(TURN+1,THING) :- turn(TURN), prustic_t(TURN,THING), not action_t(TURN,tedne,THING).",
          "type_name": "tedne"
        },
        {
          "lark": "tuate: TUATE thing\nTUATE.1: \"tuate\" WS",
          "pddl": "(:action TUATE\n    :parameters (?e - soriced_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (soriced ?e)\n        )\n    :effect (and\n        (logal ?e)\n        (not (soriced ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not soriced-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not soriced.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now logal.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To tuate is to make something soriced_able and soriced be logal.",
          "asp": "{ action_t(TURN,tuate,THING):at_t(TURN,THING,ROOM),soriced_able(THING),soriced_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nlogal_t(TURN+1,THING) :- action_t(TURN,tuate,THING).\nsoriced_t(TURN+1,THING) :- turn(TURN), soriced_t(TURN,THING), not action_t(TURN,tuate,THING).",
          "type_name": "tuate"
        },
        {
          "lark": "chross: CHROSS thing\nCHROSS.1: \"chross\" WS",
          "pddl": "(:action CHROSS\n    :parameters (?e - soriced_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (logal ?e)\n        )\n    :effect (and\n        (ramiced ?e)\n        (not (logal ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not soriced-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not logal.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now ramiced.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To chross is to make something soriced_able and logal be ramiced.",
          "asp": "{ action_t(TURN,chross,THING):at_t(TURN,THING,ROOM),soriced_able(THING),logal_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nramiced_t(TURN+1,THING) :- action_t(TURN,chross,THING).\nlogal_t(TURN+1,THING) :- turn(TURN), logal_t(TURN,THING), not action_t(TURN,chross,THING).",
          "type_name": "chross"
        },
        {
          "lark": "latory: LATORY thing\nLATORY.1: \"latory\" WS",
          "pddl": "(:action LATORY\n    :parameters (?e - soriced_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (ramiced ?e)\n        )\n    :effect (and\n        (soriced ?e)\n        (not (ramiced ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not soriced-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not ramiced.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now soriced.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To latory is to make something soriced_able and ramiced be soriced.",
          "asp": "{ action_t(TURN,latory,THING):at_t(TURN,THING,ROOM),soriced_able(THING),ramiced_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nsoriced_t(TURN+1,THING) :- action_t(TURN,latory,THING).\nramiced_t(TURN+1,THING) :- turn(TURN), ramiced_t(TURN,THING), not action_t(TURN,latory,THING).",
          "type_name": "latory"
        },
        {
          "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
          "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
          "pddl_parameter_mapping": {
            "?c": [
              "current_player_room"
            ],
            "?d": [
              "arg1"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ c }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ d }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't go to a {{ d }} from here.",
                "no_exit_to"
              ],
              [
                "You are already in the {{ d }}.",
                "going_to_current_room"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
          "epistemic": true,
          "pragmatic": true,
          "explanation": "To VERB is to move through space, especially to a place.",
          "type_name": "go"
        },
        {
          "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
          "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "You consider yourself done.",
          "asp": "",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To VERB is to end the game.",
          "type_name": "done"
        },
        {
          "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ],
            "?e": [
              "arg1"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ e }} is not an entity. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "Your inventory is not an entity. (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "{{ arg1_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to observe or inspect carefully.",
          "type_name": "examine"
        },
        {
          "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to inspect a room.",
          "type_name": "look"
        }
      ],
      "room_definitions": [
        {
          "repr_str": "penol",
          "exit_targets": [
            "fress",
            "micon"
          ],
          "max_connections": 1,
          "type_name": "penol"
        },
        {
          "repr_str": "micon",
          "exit_targets": [
            "penol"
          ],
          "max_connections": 3,
          "type_name": "micon"
        },
        {
          "repr_str": "fress",
          "exit_targets": [
            "micon",
            "catint"
          ],
          "max_connections": 2,
          "type_name": "fress"
        },
        {
          "repr_str": "catint",
          "exit_targets": [
            "fress",
            "micon",
            "penol"
          ],
          "max_connections": 2,
          "type_name": "catint"
        }
      ],
      "entity_definitions": [
        {
          "repr_str": "ortid",
          "traits": [
            "alism_able"
          ],
          "standard_locations": [
            "micon",
            "catint"
          ],
          "type_name": "ortid"
        },
        {
          "repr_str": "uncest",
          "traits": [
            "alism_able"
          ],
          "standard_locations": [
            "penol"
          ],
          "type_name": "uncest"
        },
        {
          "repr_str": "tulacy",
          "traits": [
            "enerk_able",
            "alism_able"
          ],
          "standard_locations": [
            "catint",
            "fress"
          ],
          "type_name": "tulacy"
        },
        {
          "repr_str": "unflued",
          "traits": [
            "enerk_able",
            "soriced_able"
          ],
          "standard_locations": [
            "catint"
          ],
          "type_name": "unflued"
        },
        {
          "repr_str": "pacia",
          "traits": [
            "enerk_able",
            "alism_able"
          ],
          "standard_locations": [
            "catint",
            "micon"
          ],
          "type_name": "pacia"
        },
        {
          "repr_str": "sioust",
          "traits": [
            "enerk_able"
          ],
          "standard_locations": [
            "penol",
            "catint"
          ],
          "type_name": "sioust"
        },
        {
          "repr_str": "rist",
          "traits": [
            "enerk_able"
          ],
          "standard_locations": [
            "catint"
          ],
          "type_name": "rist"
        },
        {
          "repr_str": "menny",
          "traits": [
            "soriced_able",
            "alism_able"
          ],
          "standard_locations": [
            "catint"
          ],
          "type_name": "menny"
        },
        {
          "repr_str": "inging",
          "traits": [
            "alism_able",
            "enerk_able"
          ],
          "standard_locations": [
            "micon"
          ],
          "type_name": "inging"
        },
        {
          "repr_str": "reele",
          "traits": [
            "soriced_able"
          ],
          "standard_locations": [
            "penol",
            "fress"
          ],
          "type_name": "reele"
        },
        {
          "repr_str": "you",
          "traits": [],
          "hidden": true,
          "type_name": "player"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "inventory"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "floor"
        }
      ],
      "domain_definitions": [
        {
          "domain_id": "new_words",
          "types": {
            "room": [
              "penol",
              "micon",
              "fress",
              "catint"
            ],
            "entity": [
              "player",
              "inventory",
              "floor",
              "ortid",
              "uncest",
              "tulacy",
              "unflued",
              "pacia",
              "sioust",
              "rist",
              "menny",
              "inging",
              "reele",
              "player",
              "inventory",
              "floor"
            ],
            "alism_able": [
              "ortid",
              "uncest",
              "tulacy",
              "pacia",
              "menny",
              "inging"
            ],
            "enerk_able": [
              "tulacy",
              "unflued",
              "pacia",
              "sioust",
              "rist",
              "inging"
            ],
            "soriced_able": [
              "unflued",
              "menny",
              "reele"
            ]
          },
          "predicates": [
            {
              "predicate_id": "alism",
              "variable": "e",
              "mutability": "alism_able"
            },
            {
              "predicate_id": "enerk",
              "variable": "e",
              "mutability": "enerk_able"
            },
            {
              "predicate_id": "prustic",
              "variable": "e",
              "mutability": "enerk_able"
            },
            {
              "predicate_id": "soriced",
              "variable": "e",
              "mutability": "soriced_able"
            },
            {
              "predicate_id": "logal",
              "variable": "e",
              "mutability": "soriced_able"
            },
            {
              "predicate_id": "ramiced",
              "variable": "e",
              "mutability": "soriced_able"
            }
          ]
        }
      ],
      "bench_turn_limit": 50,
      "prompt_template_set": "new-words_created"
    },
    {
      "adventure_type": "new-words_created",
      "goal": "Make the prolly lingly, the proark incry and the acion arliced.",
      "initial_state": [
        "at(dermin1,comper1)",
        "at(intler1,comess1)",
        "at(prolly1,distral1)",
        "at(rabish1,distral1)",
        "at(hypner1,distral1)",
        "at(shness1,distral1)",
        "at(arger1,distral1)",
        "at(acion1,atent1)",
        "at(evism1,comper1)",
        "at(proark1,distral1)",
        "at(player1,distral1)",
        "type(player1,player)",
        "type(proark1,proark)",
        "type(evism1,evism)",
        "type(acion1,acion)",
        "type(arger1,arger)",
        "type(shness1,shness)",
        "type(hypner1,hypner)",
        "type(rabish1,rabish)",
        "type(prolly1,prolly)",
        "type(intler1,intler)",
        "type(dermin1,dermin)",
        "room(comper1,comper)",
        "room(comess1,comess)",
        "room(atent1,atent)",
        "room(distral1,distral)",
        "arliced(intler1)",
        "arliced(rabish1)",
        "arliced(hypner1)",
        "arliced(shness1)",
        "roply(arger1)",
        "roply(acion1)",
        "lingly(dermin1)",
        "riat(arger1)",
        "psessy(prolly1)",
        "exit(comper1,comess1)",
        "exit(comess1,comper1)",
        "exit(atent1,comess1)",
        "exit(distral1,comper1)",
        "exit(comper1,distral1)",
        "exit(comess1,atent1)",
        "incry_able(proark1)",
        "incry_able(evism1)",
        "incry_able(acion1)",
        "incry_able(shness1)",
        "incry_able(prolly1)",
        "incry_able(intler1)",
        "arliced_able(acion1)",
        "arliced_able(arger1)",
        "arliced_able(shness1)",
        "arliced_able(hypner1)",
        "arliced_able(rabish1)",
        "arliced_able(intler1)",
        "lingly_able(arger1)",
        "lingly_able(prolly1)",
        "lingly_able(dermin1)"
      ],
      "goal_state": [
        "incry(proark1)",
        "arliced(acion1)",
        "lingly(prolly1)"
      ],
      "optimal_turns": 6,
      "optimal_solution": [
        [
          "deint",
          "proark1"
        ],
        [
          "lotis",
          "prolly1"
        ],
        [
          "go",
          "comper1"
        ],
        [
          "go",
          "comess1"
        ],
        [
          "go",
          "atent1"
        ],
        [
          "irear",
          "acion1"
        ]
      ],
      "optimal_commands": [
        "deint proark",
        "lotis prolly",
        "go comper",
        "go comess",
        "go atent",
        "irear acion"
      ],
      "action_definitions": [
        {
          "lark": "deint: DEINT thing\nDEINT.1: \"deint\" WS",
          "pddl": "(:action DEINT\n    :parameters (?e - incry_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (incry ?e)\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not incry-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now incry.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To deint is to make something incry_able incry.",
          "asp": "{ action_t(TURN,deint,THING):at_t(TURN,THING,ROOM),incry_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nincry_t(TURN+1,THING) :- action_t(TURN,deint,THING).\nincry_t(TURN+1,THING) :- turn(TURN), incry_t(TURN,THING).",
          "type_name": "deint"
        },
        {
          "lark": "seash: SEASH thing\nSEASH.1: \"seash\" WS",
          "pddl": "(:action SEASH\n    :parameters (?e - arliced_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (arliced ?e)\n        )\n    :effect (and\n        (roply ?e)\n        (not (arliced ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not arliced-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not arliced.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now roply.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To seash is to make something arliced_able and arliced be roply.",
          "asp": "{ action_t(TURN,seash,THING):at_t(TURN,THING,ROOM),arliced_able(THING),arliced_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nroply_t(TURN+1,THING) :- action_t(TURN,seash,THING).\narliced_t(TURN+1,THING) :- turn(TURN), arliced_t(TURN,THING), not action_t(TURN,seash,THING).",
          "type_name": "seash"
        },
        {
          "lark": "irear: IREAR thing\nIREAR.1: \"irear\" WS",
          "pddl": "(:action IREAR\n    :parameters (?e - arliced_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (roply ?e)\n        )\n    :effect (and\n        (arliced ?e)\n        (not (roply ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not arliced-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not roply.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now arliced.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To irear is to make something arliced_able and roply be arliced.",
          "asp": "{ action_t(TURN,irear,THING):at_t(TURN,THING,ROOM),arliced_able(THING),roply_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\narliced_t(TURN+1,THING) :- action_t(TURN,irear,THING).\nroply_t(TURN+1,THING) :- turn(TURN), roply_t(TURN,THING), not action_t(TURN,irear,THING).",
          "type_name": "irear"
        },
        {
          "lark": "belity: BELITY thing\nBELITY.1: \"belity\" WS",
          "pddl": "(:action BELITY\n    :parameters (?e - lingly_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (lingly ?e)\n        )\n    :effect (and\n        (riat ?e)\n        (not (lingly ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not lingly-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not lingly.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now riat.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To belity is to make something lingly_able and lingly be riat.",
          "asp": "{ action_t(TURN,belity,THING):at_t(TURN,THING,ROOM),lingly_able(THING),lingly_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nriat_t(TURN+1,THING) :- action_t(TURN,belity,THING).\nlingly_t(TURN+1,THING) :- turn(TURN), lingly_t(TURN,THING), not action_t(TURN,belity,THING).",
          "type_name": "belity"
        },
        {
          "lark": "andect: ANDECT thing\nANDECT.1: \"andect\" WS",
          "pddl": "(:action ANDECT\n    :parameters (?e - lingly_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (riat ?e)\n        )\n    :effect (and\n        (psessy ?e)\n        (not (riat ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not lingly-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not riat.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now psessy.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To andect is to make something lingly_able and riat be psessy.",
          "asp": "{ action_t(TURN,andect,THING):at_t(TURN,THING,ROOM),lingly_able(THING),riat_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\npsessy_t(TURN+1,THING) :- action_t(TURN,andect,THING).\nriat_t(TURN+1,THING) :- turn(TURN), riat_t(TURN,THING), not action_t(TURN,andect,THING).",
          "type_name": "andect"
        },
        {
          "lark": "lotis: LOTIS thing\nLOTIS.1: \"lotis\" WS",
          "pddl": "(:action LOTIS\n    :parameters (?e - lingly_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (psessy ?e)\n        )\n    :effect (and\n        (lingly ?e)\n        (not (psessy ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not lingly-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not psessy.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now lingly.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To lotis is to make something lingly_able and psessy be lingly.",
          "asp": "{ action_t(TURN,lotis,THING):at_t(TURN,THING,ROOM),lingly_able(THING),psessy_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nlingly_t(TURN+1,THING) :- action_t(TURN,lotis,THING).\npsessy_t(TURN+1,THING) :- turn(TURN), psessy_t(TURN,THING), not action_t(TURN,lotis,THING).",
          "type_name": "lotis"
        },
        {
          "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
          "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
          "pddl_parameter_mapping": {
            "?c": [
              "current_player_room"
            ],
            "?d": [
              "arg1"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ c }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ d }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't go to a {{ d }} from here.",
                "no_exit_to"
              ],
              [
                "You are already in the {{ d }}.",
                "going_to_current_room"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
          "epistemic": true,
          "pragmatic": true,
          "explanation": "To VERB is to move through space, especially to a place.",
          "type_name": "go"
        },
        {
          "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
          "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "You consider yourself done.",
          "asp": "",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To VERB is to end the game.",
          "type_name": "done"
        },
        {
          "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ],
            "?e": [
              "arg1"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ e }} is not an entity. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "Your inventory is not an entity. (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "{{ arg1_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to observe or inspect carefully.",
          "type_name": "examine"
        },
        {
          "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to inspect a room.",
          "type_name": "look"
        }
      ],
      "room_definitions": [
        {
          "repr_str": "comper",
          "exit_targets": [
            "atent",
            "comess"
          ],
          "max_connections": 1,
          "type_name": "comper"
        },
        {
          "repr_str": "comess",
          "exit_targets": [
            "comper"
          ],
          "max_connections": 3,
          "type_name": "comess"
        },
        {
          "repr_str": "atent",
          "exit_targets": [
            "comess",
            "distral"
          ],
          "max_connections": 2,
          "type_name": "atent"
        },
        {
          "repr_str": "distral",
          "exit_targets": [
            "atent",
            "comess",
            "comper"
          ],
          "max_connections": 2,
          "type_name": "distral"
        }
      ],
      "entity_definitions": [
        {
          "repr_str": "proark",
          "traits": [
            "incry_able"
          ],
          "standard_locations": [
            "comess",
            "distral"
          ],
          "type_name": "proark"
        },
        {
          "repr_str": "evism",
          "traits": [
            "incry_able"
          ],
          "standard_locations": [
            "comper"
          ],
          "type_name": "evism"
        },
        {
          "repr_str": "acion",
          "traits": [
            "arliced_able",
            "incry_able"
          ],
          "standard_locations": [
            "distral",
            "atent"
          ],
          "type_name": "acion"
        },
        {
          "repr_str": "arger",
          "traits": [
            "arliced_able",
            "lingly_able"
          ],
          "standard_locations": [
            "distral"
          ],
          "type_name": "arger"
        },
        {
          "repr_str": "shness",
          "traits": [
            "arliced_able",
            "incry_able"
          ],
          "standard_locations": [
            "distral",
            "comess"
          ],
          "type_name": "shness"
        },
        {
          "repr_str": "hypner",
          "traits": [
            "arliced_able"
          ],
          "standard_locations": [
            "comper",
            "distral"
          ],
          "type_name": "hypner"
        },
        {
          "repr_str": "rabish",
          "traits": [
            "arliced_able"
          ],
          "standard_locations": [
            "distral"
          ],
          "type_name": "rabish"
        },
        {
          "repr_str": "prolly",
          "traits": [
            "lingly_able",
            "incry_able"
          ],
          "standard_locations": [
            "distral"
          ],
          "type_name": "prolly"
        },
        {
          "repr_str": "intler",
          "traits": [
            "incry_able",
            "arliced_able"
          ],
          "standard_locations": [
            "comess"
          ],
          "type_name": "intler"
        },
        {
          "repr_str": "dermin",
          "traits": [
            "lingly_able"
          ],
          "standard_locations": [
            "comper",
            "atent"
          ],
          "type_name": "dermin"
        },
        {
          "repr_str": "you",
          "traits": [],
          "hidden": true,
          "type_name": "player"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "inventory"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "floor"
        }
      ],
      "domain_definitions": [
        {
          "domain_id": "new_words",
          "types": {
            "room": [
              "comper",
              "comess",
              "atent",
              "distral"
            ],
            "entity": [
              "player",
              "inventory",
              "floor",
              "proark",
              "evism",
              "acion",
              "arger",
              "shness",
              "hypner",
              "rabish",
              "prolly",
              "intler",
              "dermin",
              "player",
              "inventory",
              "floor"
            ],
            "incry_able": [
              "proark",
              "evism",
              "acion",
              "shness",
              "prolly",
              "intler"
            ],
            "arliced_able": [
              "acion",
              "arger",
              "shness",
              "hypner",
              "rabish",
              "intler"
            ],
            "lingly_able": [
              "arger",
              "prolly",
              "dermin"
            ]
          },
          "predicates": [
            {
              "predicate_id": "incry",
              "variable": "e",
              "mutability": "incry_able"
            },
            {
              "predicate_id": "arliced",
              "variable": "e",
              "mutability": "arliced_able"
            },
            {
              "predicate_id": "roply",
              "variable": "e",
              "mutability": "arliced_able"
            },
            {
              "predicate_id": "lingly",
              "variable": "e",
              "mutability": "lingly_able"
            },
            {
              "predicate_id": "riat",
              "variable": "e",
              "mutability": "lingly_able"
            },
            {
              "predicate_id": "psessy",
              "variable": "e",
              "mutability": "lingly_able"
            }
          ]
        }
      ],
      "bench_turn_limit": 50,
      "prompt_template_set": "new-words_created"
    },
    {
      "adventure_type": "new-words_created",
      "goal": "Make the strood aphistic, the aciong dolam and the swaiced ailly.",
      "initial_state": [
        "at(ostion1,stful1)",
        "at(pyelly1,emoust1)",
        "at(strood1,encal1)",
        "at(eucty1,encal1)",
        "at(inchan1,encal1)",
        "at(oming1,encal1)",
        "at(perent1,encal1)",
        "at(swaiced1,etiont1)",
        "at(oroust1,stful1)",
        "at(aciong1,encal1)",
        "at(player1,encal1)",
        "type(player1,player)",
        "type(aciong1,aciong)",
        "type(oroust1,oroust)",
        "type(swaiced1,swaiced)",
        "type(perent1,perent)",
        "type(oming1,oming)",
        "type(inchan1,inchan)",
        "type(eucty1,eucty)",
        "type(strood1,strood)",
        "type(pyelly1,pyelly)",
        "type(ostion1,ostion)",
        "room(stful1,stful)",
        "room(emoust1,emoust)",
        "room(etiont1,etiont)",
        "room(encal1,encal)",
        "ailly(pyelly1)",
        "ailly(eucty1)",
        "ailly(inchan1)",
        "ailly(oming1)",
        "retart(perent1)",
        "retart(swaiced1)",
        "aphistic(ostion1)",
        "olict(perent1)",
        "eriated(strood1)",
        "exit(stful1,emoust1)",
        "exit(emoust1,stful1)",
        "exit(etiont1,emoust1)",
        "exit(encal1,stful1)",
        "exit(stful1,encal1)",
        "exit(emoust1,etiont1)",
        "dolam_able(aciong1)",
        "dolam_able(oroust1)",
        "dolam_able(swaiced1)",
        "dolam_able(oming1)",
        "dolam_able(strood1)",
        "dolam_able(pyelly1)",
        "ailly_able(swaiced1)",
        "ailly_able(perent1)",
        "ailly_able(oming1)",
        "ailly_able(inchan1)",
        "ailly_able(eucty1)",
        "ailly_able(pyelly1)",
        "aphistic_able(perent1)",
        "aphistic_able(strood1)",
        "aphistic_able(ostion1)"
      ],
      "goal_state": [
        "dolam(aciong1)",
        "ailly(swaiced1)",
        "aphistic(strood1)"
      ],
      "optimal_turns": 6,
      "optimal_solution": [
        [
          "eriat",
          "aciong1"
        ],
        [
          "setral",
          "strood1"
        ],
        [
          "go",
          "stful1"
        ],
        [
          "go",
          "emoust1"
        ],
        [
          "go",
          "etiont1"
        ],
        [
          "mingne",
          "swaiced1"
        ]
      ],
      "optimal_commands": [
        "eriat aciong",
        "setral strood",
        "go stful",
        "go emoust",
        "go etiont",
        "mingne swaiced"
      ],
      "action_definitions": [
        {
          "lark": "eriat: ERIAT thing\nERIAT.1: \"eriat\" WS",
          "pddl": "(:action ERIAT\n    :parameters (?e - dolam_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (dolam ?e)\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not dolam-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now dolam.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To eriat is to make something dolam_able dolam.",
          "asp": "{ action_t(TURN,eriat,THING):at_t(TURN,THING,ROOM),dolam_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\ndolam_t(TURN+1,THING) :- action_t(TURN,eriat,THING).\ndolam_t(TURN+1,THING) :- turn(TURN), dolam_t(TURN,THING).",
          "type_name": "eriat"
        },
        {
          "lark": "ovesis: OVESIS thing\nOVESIS.1: \"ovesis\" WS",
          "pddl": "(:action OVESIS\n    :parameters (?e - ailly_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (ailly ?e)\n        )\n    :effect (and\n        (retart ?e)\n        (not (ailly ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not ailly-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not ailly.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now retart.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To ovesis is to make something ailly_able and ailly be retart.",
          "asp": "{ action_t(TURN,ovesis,THING):at_t(TURN,THING,ROOM),ailly_able(THING),ailly_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nretart_t(TURN+1,THING) :- action_t(TURN,ovesis,THING).\nailly_t(TURN+1,THING) :- turn(TURN), ailly_t(TURN,THING), not action_t(TURN,ovesis,THING).",
          "type_name": "ovesis"
        },
        {
          "lark": "mingne: MINGNE thing\nMINGNE.1: \"mingne\" WS",
          "pddl": "(:action MINGNE\n    :parameters (?e - ailly_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (retart ?e)\n        )\n    :effect (and\n        (ailly ?e)\n        (not (retart ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not ailly-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not retart.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now ailly.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To mingne is to make something ailly_able and retart be ailly.",
          "asp": "{ action_t(TURN,mingne,THING):at_t(TURN,THING,ROOM),ailly_able(THING),retart_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nailly_t(TURN+1,THING) :- action_t(TURN,mingne,THING).\nretart_t(TURN+1,THING) :- turn(TURN), retart_t(TURN,THING), not action_t(TURN,mingne,THING).",
          "type_name": "mingne"
        },
        {
          "lark": "lepht: LEPHT thing\nLEPHT.1: \"lepht\" WS",
          "pddl": "(:action LEPHT\n    :parameters (?e - aphistic_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (aphistic ?e)\n        )\n    :effect (and\n        (olict ?e)\n        (not (aphistic ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not aphistic-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not aphistic.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now olict.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To lepht is to make something aphistic_able and aphistic be olict.",
          "asp": "{ action_t(TURN,lepht,THING):at_t(TURN,THING,ROOM),aphistic_able(THING),aphistic_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nolict_t(TURN+1,THING) :- action_t(TURN,lepht,THING).\naphistic_t(TURN+1,THING) :- turn(TURN), aphistic_t(TURN,THING), not action_t(TURN,lepht,THING).",
          "type_name": "lepht"
        },
        {
          "lark": "iscad: ISCAD thing\nISCAD.1: \"iscad\" WS",
          "pddl": "(:action ISCAD\n    :parameters (?e - aphistic_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (olict ?e)\n        )\n    :effect (and\n        (eriated ?e)\n        (not (olict ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not aphistic-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not olict.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now eriated.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To iscad is to make something aphistic_able and olict be eriated.",
          "asp": "{ action_t(TURN,iscad,THING):at_t(TURN,THING,ROOM),aphistic_able(THING),olict_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\neriated_t(TURN+1,THING) :- action_t(TURN,iscad,THING).\nolict_t(TURN+1,THING) :- turn(TURN), olict_t(TURN,THING), not action_t(TURN,iscad,THING).",
          "type_name": "iscad"
        },
        {
          "lark": "setral: SETRAL thing\nSETRAL.1: \"setral\" WS",
          "pddl": "(:action SETRAL\n    :parameters (?e - aphistic_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (eriated ?e)\n        )\n    :effect (and\n        (aphistic ?e)\n        (not (eriated ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not aphistic-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not eriated.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now aphistic.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To setral is to make something aphistic_able and eriated be aphistic.",
          "asp": "{ action_t(TURN,setral,THING):at_t(TURN,THING,ROOM),aphistic_able(THING),eriated_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\naphistic_t(TURN+1,THING) :- action_t(TURN,setral,THING).\neriated_t(TURN+1,THING) :- turn(TURN), eriated_t(TURN,THING), not action_t(TURN,setral,THING).",
          "type_name": "setral"
        },
        {
          "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
          "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
          "pddl_parameter_mapping": {
            "?c": [
              "current_player_room"
            ],
            "?d": [
              "arg1"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ c }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ d }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't go to a {{ d }} from here.",
                "no_exit_to"
              ],
              [
                "You are already in the {{ d }}.",
                "going_to_current_room"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
          "epistemic": true,
          "pragmatic": true,
          "explanation": "To VERB is to move through space, especially to a place.",
          "type_name": "go"
        },
        {
          "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
          "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "You consider yourself done.",
          "asp": "",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To VERB is to end the game.",
          "type_name": "done"
        },
        {
          "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ],
            "?e": [
              "arg1"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ e }} is not an entity. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "Your inventory is not an entity. (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "{{ arg1_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to observe or inspect carefully.",
          "type_name": "examine"
        },
        {
          "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to inspect a room.",
          "type_name": "look"
        }
      ],
      "room_definitions": [
        {
          "repr_str": "stful",
          "exit_targets": [
            "etiont",
            "emoust"
          ],
          "max_connections": 1,
          "type_name": "stful"
        },
        {
          "repr_str": "emoust",
          "exit_targets": [
            "stful"
          ],
          "max_connections": 3,
          "type_name": "emoust"
        },
        {
          "repr_str": "etiont",
          "exit_targets": [
            "emoust",
            "encal"
          ],
          "max_connections": 2,
          "type_name": "etiont"
        },
        {
          "repr_str": "encal",
          "exit_targets": [
            "etiont",
            "emoust",
            "stful"
          ],
          "max_connections": 2,
          "type_name": "encal"
        }
      ],
      "entity_definitions": [
        {
          "repr_str": "aciong",
          "traits": [
            "dolam_able"
          ],
          "standard_locations": [
            "emoust",
            "encal"
          ],
          "type_name": "aciong"
        },
        {
          "repr_str": "oroust",
          "traits": [
            "dolam_able"
          ],
          "standard_locations": [
            "stful"
          ],
          "type_name": "oroust"
        },
        {
          "repr_str": "swaiced",
          "traits": [
            "ailly_able",
            "dolam_able"
          ],
          "standard_locations": [
            "encal",
            "etiont"
          ],
          "type_name": "swaiced"
        },
        {
          "repr_str": "perent",
          "traits": [
            "ailly_able",
            "aphistic_able"
          ],
          "standard_locations": [
            "encal"
          ],
          "type_name": "perent"
        },
        {
          "repr_str": "oming",
          "traits": [
            "ailly_able",
            "dolam_able"
          ],
          "standard_locations": [
            "encal",
            "emoust"
          ],
          "type_name": "oming"
        },
        {
          "repr_str": "inchan",
          "traits": [
            "ailly_able"
          ],
          "standard_locations": [
            "stful",
            "encal"
          ],
          "type_name": "inchan"
        },
        {
          "repr_str": "eucty",
          "traits": [
            "ailly_able"
          ],
          "standard_locations": [
            "encal"
          ],
          "type_name": "eucty"
        },
        {
          "repr_str": "strood",
          "traits": [
            "aphistic_able",
            "dolam_able"
          ],
          "standard_locations": [
            "encal"
          ],
          "type_name": "strood"
        },
        {
          "repr_str": "pyelly",
          "traits": [
            "dolam_able",
            "ailly_able"
          ],
          "standard_locations": [
            "emoust"
          ],
          "type_name": "pyelly"
        },
        {
          "repr_str": "ostion",
          "traits": [
            "aphistic_able"
          ],
          "standard_locations": [
            "stful",
            "etiont"
          ],
          "type_name": "ostion"
        },
        {
          "repr_str": "you",
          "traits": [],
          "hidden": true,
          "type_name": "player"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "inventory"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "floor"
        }
      ],
      "domain_definitions": [
        {
          "domain_id": "new_words",
          "types": {
            "room": [
              "stful",
              "emoust",
              "etiont",
              "encal"
            ],
            "entity": [
              "player",
              "inventory",
              "floor",
              "aciong",
              "oroust",
              "swaiced",
              "perent",
              "oming",
              "inchan",
              "eucty",
              "strood",
              "pyelly",
              "ostion",
              "player",
              "inventory",
              "floor"
            ],
            "dolam_able": [
              "aciong",
              "oroust",
              "swaiced",
              "oming",
              "strood",
              "pyelly"
            ],
            "ailly_able": [
              "swaiced",
              "perent",
              "oming",
              "inchan",
              "eucty",
              "pyelly"
            ],
            "aphistic_able": [
              "perent",
              "strood",
              "ostion"
            ]
          },
          "predicates": [
            {
              "predicate_id": "dolam",
              "variable": "e",
              "mutability": "dolam_able"
            },
            {
              "predicate_id": "ailly",
              "variable": "e",
              "mutability": "ailly_able"
            },
            {
              "predicate_id": "retart",
              "variable": "e",
              "mutability": "ailly_able"
            },
            {
              "predicate_id": "aphistic",
              "variable": "e",
              "mutability": "aphistic_able"
            },
            {
              "predicate_id": "olict",
              "variable": "e",
              "mutability": "aphistic_able"
            },
            {
              "predicate_id": "eriated",
              "variable": "e",
              "mutability": "aphistic_able"
            }
          ]
        }
      ],
      "bench_turn_limit": 50,
      "prompt_template_set": "new-words_created"
    },
    {
      "adventure_type": "new-words_created",
      "goal": "Make the eprour reging, the siaticed degra and the piesm ricke.",
      "initial_state": [
        "at(taillag1,lablent1)",
        "at(dergal1,tworia1)",
        "at(siaticed1,lon1)",
        "at(riack1,lon1)",
        "at(astont1,lon1)",
        "at(orele1,lon1)",
        "at(teming1,lon1)",
        "at(piesm1,lispe1)",
        "at(iless1,lablent1)",
        "at(eprour1,lon1)",
        "at(player1,lon1)",
        "type(player1,player)",
        "type(eprour1,eprour)",
        "type(iless1,iless)",
        "type(piesm1,piesm)",
        "type(teming1,teming)",
        "type(orele1,orele)",
        "type(astont1,astont)",
        "type(riack1,riack)",
        "type(siaticed1,siaticed)",
        "type(dergal1,dergal)",
        "type(taillag1,taillag)",
        "room(lablent1,lablent)",
        "room(tworia1,tworia)",
        "room(lispe1,lispe)",
        "room(lon1,lon)",
        "ricke(dergal1)",
        "ricke(riack1)",
        "ricke(astont1)",
        "ricke(orele1)",
        "ricary(teming1)",
        "ricary(piesm1)",
        "degra(taillag1)",
        "babile(teming1)",
        "scidian(siaticed1)",
        "exit(lablent1,tworia1)",
        "exit(tworia1,lablent1)",
        "exit(lispe1,tworia1)",
        "exit(lon1,lablent1)",
        "exit(lablent1,lon1)",
        "exit(tworia1,lispe1)",
        "reging_able(eprour1)",
        "reging_able(iless1)",
        "reging_able(piesm1)",
        "reging_able(orele1)",
        "reging_able(siaticed1)",
        "reging_able(dergal1)",
        "ricke_able(piesm1)",
        "ricke_able(teming1)",
        "ricke_able(orele1)",
        "ricke_able(astont1)",
        "ricke_able(riack1)",
        "ricke_able(dergal1)",
        "degra_able(teming1)",
        "degra_able(siaticed1)",
        "degra_able(taillag1)"
      ],
      "goal_state": [
        "reging(eprour1)",
        "ricke(piesm1)",
        "degra(siaticed1)"
      ],
      "optimal_turns": 6,
      "optimal_solution": [
        [
          "cretia",
          "eprour1"
        ],
        [
          "erack",
          "siaticed1"
        ],
        [
          "go",
          "lablent1"
        ],
        [
          "go",
          "tworia1"
        ],
        [
          "go",
          "lispe1"
        ],
        [
          "icalit",
          "piesm1"
        ]
      ],
      "optimal_commands": [
        "cretia eprour",
        "erack siaticed",
        "go lablent",
        "go tworia",
        "go lispe",
        "icalit piesm"
      ],
      "action_definitions": [
        {
          "lark": "cretia: CRETIA thing\nCRETIA.1: \"cretia\" WS",
          "pddl": "(:action CRETIA\n    :parameters (?e - reging_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (reging ?e)\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not reging-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now reging.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To cretia is to make something reging_able reging.",
          "asp": "{ action_t(TURN,cretia,THING):at_t(TURN,THING,ROOM),reging_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nreging_t(TURN+1,THING) :- action_t(TURN,cretia,THING).\nreging_t(TURN+1,THING) :- turn(TURN), reging_t(TURN,THING).",
          "type_name": "cretia"
        },
        {
          "lark": "crury: CRURY thing\nCRURY.1: \"crury\" WS",
          "pddl": "(:action CRURY\n    :parameters (?e - ricke_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (ricke ?e)\n        )\n    :effect (and\n        (ricary ?e)\n        (not (ricke ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not ricke-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not ricke.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now ricary.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To crury is to make something ricke_able and ricke be ricary.",
          "asp": "{ action_t(TURN,crury,THING):at_t(TURN,THING,ROOM),ricke_able(THING),ricke_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nricary_t(TURN+1,THING) :- action_t(TURN,crury,THING).\nricke_t(TURN+1,THING) :- turn(TURN), ricke_t(TURN,THING), not action_t(TURN,crury,THING).",
          "type_name": "crury"
        },
        {
          "lark": "icalit: ICALIT thing\nICALIT.1: \"icalit\" WS",
          "pddl": "(:action ICALIT\n    :parameters (?e - ricke_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (ricary ?e)\n        )\n    :effect (and\n        (ricke ?e)\n        (not (ricary ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not ricke-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not ricary.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now ricke.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To icalit is to make something ricke_able and ricary be ricke.",
          "asp": "{ action_t(TURN,icalit,THING):at_t(TURN,THING,ROOM),ricke_able(THING),ricary_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nricke_t(TURN+1,THING) :- action_t(TURN,icalit,THING).\nricary_t(TURN+1,THING) :- turn(TURN), ricary_t(TURN,THING), not action_t(TURN,icalit,THING).",
          "type_name": "icalit"
        },
        {
          "lark": "lowal: LOWAL thing\nLOWAL.1: \"lowal\" WS",
          "pddl": "(:action LOWAL\n    :parameters (?e - degra_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (degra ?e)\n        )\n    :effect (and\n        (babile ?e)\n        (not (degra ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not degra-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not degra.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now babile.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To lowal is to make something degra_able and degra be babile.",
          "asp": "{ action_t(TURN,lowal,THING):at_t(TURN,THING,ROOM),degra_able(THING),degra_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nbabile_t(TURN+1,THING) :- action_t(TURN,lowal,THING).\ndegra_t(TURN+1,THING) :- turn(TURN), degra_t(TURN,THING), not action_t(TURN,lowal,THING).",
          "type_name": "lowal"
        },
        {
          "lark": "plecon: PLECON thing\nPLECON.1: \"plecon\" WS",
          "pddl": "(:action PLECON\n    :parameters (?e - degra_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (babile ?e)\n        )\n    :effect (and\n        (scidian ?e)\n        (not (babile ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not degra-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not babile.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now scidian.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To plecon is to make something degra_able and babile be scidian.",
          "asp": "{ action_t(TURN,plecon,THING):at_t(TURN,THING,ROOM),degra_able(THING),babile_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nscidian_t(TURN+1,THING) :- action_t(TURN,plecon,THING).\nbabile_t(TURN+1,THING) :- turn(TURN), babile_t(TURN,THING), not action_t(TURN,plecon,THING).",
          "type_name": "plecon"
        },
        {
          "lark": "erack: ERACK thing\nERACK.1: \"erack\" WS",
          "pddl": "(:action ERACK\n    :parameters (?e - degra_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (scidian ?e)\n        )\n    :effect (and\n        (degra ?e)\n        (not (scidian ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not degra-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not scidian.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now degra.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To erack is to make something degra_able and scidian be degra.",
          "asp": "{ action_t(TURN,erack,THING):at_t(TURN,THING,ROOM),degra_able(THING),scidian_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\ndegra_t(TURN+1,THING) :- action_t(TURN,erack,THING).\nscidian_t(TURN+1,THING) :- turn(TURN), scidian_t(TURN,THING), not action_t(TURN,erack,THING).",
          "type_name": "erack"
        },
        {
          "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
          "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
          "pddl_parameter_mapping": {
            "?c": [
              "current_player_room"
            ],
            "?d": [
              "arg1"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ c }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ d }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't go to a {{ d }} from here.",
                "no_exit_to"
              ],
              [
                "You are already in the {{ d }}.",
                "going_to_current_room"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
          "epistemic": true,
          "pragmatic": true,
          "explanation": "To VERB is to move through space, especially to a place.",
          "type_name": "go"
        },
        {
          "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
          "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "You consider yourself done.",
          "asp": "",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To VERB is to end the game.",
          "type_name": "done"
        },
        {
          "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ],
            "?e": [
              "arg1"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ e }} is not an entity. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "Your inventory is not an entity. (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "{{ arg1_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to observe or inspect carefully.",
          "type_name": "examine"
        },
        {
          "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to inspect a room.",
          "type_name": "look"
        }
      ],
      "room_definitions": [
        {
          "repr_str": "lablent",
          "exit_targets": [
            "lispe",
            "tworia"
          ],
          "max_connections": 1,
          "type_name": "lablent"
        },
        {
          "repr_str": "tworia",
          "exit_targets": [
            "lablent"
          ],
          "max_connections": 3,
          "type_name": "tworia"
        },
        {
          "repr_str": "lispe",
          "exit_targets": [
            "tworia",
            "lon"
          ],
          "max_connections": 2,
          "type_name": "lispe"
        },
        {
          "repr_str": "lon",
          "exit_targets": [
            "lispe",
            "tworia",
            "lablent"
          ],
          "max_connections": 2,
          "type_name": "lon"
        }
      ],
      "entity_definitions": [
        {
          "repr_str": "eprour",
          "traits": [
            "reging_able"
          ],
          "standard_locations": [
            "tworia",
            "lon"
          ],
          "type_name": "eprour"
        },
        {
          "repr_str": "iless",
          "traits": [
            "reging_able"
          ],
          "standard_locations": [
            "lablent"
          ],
          "type_name": "iless"
        },
        {
          "repr_str": "piesm",
          "traits": [
            "ricke_able",
            "reging_able"
          ],
          "standard_locations": [
            "lon",
            "lispe"
          ],
          "type_name": "piesm"
        },
        {
          "repr_str": "teming",
          "traits": [
            "ricke_able",
            "degra_able"
          ],
          "standard_locations": [
            "lon"
          ],
          "type_name": "teming"
        },
        {
          "repr_str": "orele",
          "traits": [
            "ricke_able",
            "reging_able"
          ],
          "standard_locations": [
            "lon",
            "tworia"
          ],
          "type_name": "orele"
        },
        {
          "repr_str": "astont",
          "traits": [
            "ricke_able"
          ],
          "standard_locations": [
            "lablent",
            "lon"
          ],
          "type_name": "astont"
        },
        {
          "repr_str": "riack",
          "traits": [
            "ricke_able"
          ],
          "standard_locations": [
            "lon"
          ],
          "type_name": "riack"
        },
        {
          "repr_str": "siaticed",
          "traits": [
            "degra_able",
            "reging_able"
          ],
          "standard_locations": [
            "lon"
          ],
          "type_name": "siaticed"
        },
        {
          "repr_str": "dergal",
          "traits": [
            "reging_able",
            "ricke_able"
          ],
          "standard_locations": [
            "tworia"
          ],
          "type_name": "dergal"
        },
        {
          "repr_str": "taillag",
          "traits": [
            "degra_able"
          ],
          "standard_locations": [
            "lablent",
            "lispe"
          ],
          "type_name": "taillag"
        },
        {
          "repr_str": "you",
          "traits": [],
          "hidden": true,
          "type_name": "player"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "inventory"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "floor"
        }
      ],
      "domain_definitions": [
        {
          "domain_id": "new_words",
          "types": {
            "room": [
              "lablent",
              "tworia",
              "lispe",
              "lon"
            ],
            "entity": [
              "player",
              "inventory",
              "floor",
              "eprour",
              "iless",
              "piesm",
              "teming",
              "orele",
              "astont",
              "riack",
              "siaticed",
              "dergal",
              "taillag",
              "player",
              "inventory",
              "floor"
            ],
            "reging_able": [
              "eprour",
              "iless",
              "piesm",
              "orele",
              "siaticed",
              "dergal"
            ],
            "ricke_able": [
              "piesm",
              "teming",
              "orele",
              "astont",
              "riack",
              "dergal"
            ],
            "degra_able": [
              "teming",
              "siaticed",
              "taillag"
            ]
          },
          "predicates": [
            {
              "predicate_id": "reging",
              "variable": "e",
              "mutability": "reging_able"
            },
            {
              "predicate_id": "ricke",
              "variable": "e",
              "mutability": "ricke_able"
            },
            {
              "predicate_id": "ricary",
              "variable": "e",
              "mutability": "ricke_able"
            },
            {
              "predicate_id": "degra",
              "variable": "e",
              "mutability": "degra_able"
            },
            {
              "predicate_id": "babile",
              "variable": "e",
              "mutability": "degra_able"
            },
            {
              "predicate_id": "scidian",
              "variable": "e",
              "mutability": "degra_able"
            }
          ]
        }
      ],
      "bench_turn_limit": 50,
      "prompt_template_set": "new-words_created"
    },
    {
      "adventure_type": "new-words_created",
      "goal": "Make the torhy padery, the rot lotta and the astable preciny.",
      "initial_state": [
        "at(rialiced1,ram1)",
        "at(ilitid1,stingly1)",
        "at(torhy1,iscum1)",
        "at(tisof1,iscum1)",
        "at(hirry1,iscum1)",
        "at(ishing1,iscum1)",
        "at(lonon1,iscum1)",
        "at(rot1,atoust1)",
        "at(omante1,ram1)",
        "at(astable1,iscum1)",
        "at(player1,iscum1)",
        "type(player1,player)",
        "type(astable1,astable)",
        "type(omante1,omante)",
        "type(rot1,rot)",
        "type(lonon1,lonon)",
        "type(ishing1,ishing)",
        "type(hirry1,hirry)",
        "type(tisof1,tisof)",
        "type(torhy1,torhy)",
        "type(ilitid1,ilitid)",
        "type(rialiced1,rialiced)",
        "room(ram1,ram)",
        "room(stingly1,stingly)",
        "room(atoust1,atoust)",
        "room(iscum1,iscum)",
        "lotta(ilitid1)",
        "lotta(tisof1)",
        "lotta(hirry1)",
        "lotta(ishing1)",
        "gumary(lonon1)",
        "gumary(rot1)",
        "padery(rialiced1)",
        "antally(lonon1)",
        "helum(torhy1)",
        "exit(ram1,stingly1)",
        "exit(stingly1,ram1)",
        "exit(atoust1,stingly1)",
        "exit(iscum1,ram1)",
        "exit(ram1,iscum1)",
        "exit(stingly1,atoust1)",
        "preciny_able(astable1)",
        "preciny_able(omante1)",
        "preciny_able(rot1)",
        "preciny_able(ishing1)",
        "preciny_able(torhy1)",
        "preciny_able(ilitid1)",
        "lotta_able(rot1)",
        "lotta_able(lonon1)",
        "lotta_able(ishing1)",
        "lotta_able(hirry1)",
        "lotta_able(tisof1)",
        "lotta_able(ilitid1)",
        "padery_able(lonon1)",
        "padery_able(torhy1)",
        "padery_able(rialiced1)"
      ],
      "goal_state": [
        "preciny(astable1)",
        "lotta(rot1)",
        "padery(torhy1)"
      ],
      "optimal_turns": 6,
      "optimal_solution": [
        [
          "bioch",
          "astable1"
        ],
        [
          "emood",
          "torhy1"
        ],
        [
          "go",
          "ram1"
        ],
        [
          "go",
          "stingly1"
        ],
        [
          "go",
          "atoust1"
        ],
        [
          "snemic",
          "rot1"
        ]
      ],
      "optimal_commands": [
        "bioch astable",
        "emood torhy",
        "go ram",
        "go stingly",
        "go atoust",
        "snemic rot"
      ],
      "action_definitions": [
        {
          "lark": "bioch: BIOCH thing\nBIOCH.1: \"bioch\" WS",
          "pddl": "(:action BIOCH\n    :parameters (?e - preciny_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (preciny ?e)\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not preciny-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now preciny.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To bioch is to make something preciny_able preciny.",
          "asp": "{ action_t(TURN,bioch,THING):at_t(TURN,THING,ROOM),preciny_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\npreciny_t(TURN+1,THING) :- action_t(TURN,bioch,THING).\npreciny_t(TURN+1,THING) :- turn(TURN), preciny_t(TURN,THING).",
          "type_name": "bioch"
        },
        {
          "lark": "erson: ERSON thing\nERSON.1: \"erson\" WS",
          "pddl": "(:action ERSON\n    :parameters (?e - lotta_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (lotta ?e)\n        )\n    :effect (and\n        (gumary ?e)\n        (not (lotta ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not lotta-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not lotta.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now gumary.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To erson is to make something lotta_able and lotta be gumary.",
          "asp": "{ action_t(TURN,erson,THING):at_t(TURN,THING,ROOM),lotta_able(THING),lotta_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\ngumary_t(TURN+1,THING) :- action_t(TURN,erson,THING).\nlotta_t(TURN+1,THING) :- turn(TURN), lotta_t(TURN,THING), not action_t(TURN,erson,THING).",
          "type_name": "erson"
        },
        {
          "lark": "snemic: SNEMIC thing\nSNEMIC.1: \"snemic\" WS",
          "pddl": "(:action SNEMIC\n    :parameters (?e - lotta_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (gumary ?e)\n        )\n    :effect (and\n        (lotta ?e)\n        (not (gumary ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not lotta-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not gumary.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now lotta.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To snemic is to make something lotta_able and gumary be lotta.",
          "asp": "{ action_t(TURN,snemic,THING):at_t(TURN,THING,ROOM),lotta_able(THING),gumary_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nlotta_t(TURN+1,THING) :- action_t(TURN,snemic,THING).\ngumary_t(TURN+1,THING) :- turn(TURN), gumary_t(TURN,THING), not action_t(TURN,snemic,THING).",
          "type_name": "snemic"
        },
        {
          "lark": "intess: INTESS thing\nINTESS.1: \"intess\" WS",
          "pddl": "(:action INTESS\n    :parameters (?e - padery_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (padery ?e)\n        )\n    :effect (and\n        (antally ?e)\n        (not (padery ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not padery-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not padery.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now antally.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To intess is to make something padery_able and padery be antally.",
          "asp": "{ action_t(TURN,intess,THING):at_t(TURN,THING,ROOM),padery_able(THING),padery_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nantally_t(TURN+1,THING) :- action_t(TURN,intess,THING).\npadery_t(TURN+1,THING) :- turn(TURN), padery_t(TURN,THING), not action_t(TURN,intess,THING).",
          "type_name": "intess"
        },
        {
          "lark": "oustion: OUSTION thing\nOUSTION.1: \"oustion\" WS",
          "pddl": "(:action OUSTION\n    :parameters (?e - padery_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (antally ?e)\n        )\n    :effect (and\n        (helum ?e)\n        (not (antally ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not padery-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not antally.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now helum.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To oustion is to make something padery_able and antally be helum.",
          "asp": "{ action_t(TURN,oustion,THING):at_t(TURN,THING,ROOM),padery_able(THING),antally_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nhelum_t(TURN+1,THING) :- action_t(TURN,oustion,THING).\nantally_t(TURN+1,THING) :- turn(TURN), antally_t(TURN,THING), not action_t(TURN,oustion,THING).",
          "type_name": "oustion"
        },
        {
          "lark": "emood: EMOOD thing\nEMOOD.1: \"emood\" WS",
          "pddl": "(:action EMOOD\n    :parameters (?e - padery_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (helum ?e)\n        )\n    :effect (and\n        (padery ?e)\n        (not (helum ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not padery-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not helum.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now padery.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To emood is to make something padery_able and helum be padery.",
          "asp": "{ action_t(TURN,emood,THING):at_t(TURN,THING,ROOM),padery_able(THING),helum_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\npadery_t(TURN+1,THING) :- action_t(TURN,emood,THING).\nhelum_t(TURN+1,THING) :- turn(TURN), helum_t(TURN,THING), not action_t(TURN,emood,THING).",
          "type_name": "emood"
        },
        {
          "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
          "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
          "pddl_parameter_mapping": {
            "?c": [
              "current_player_room"
            ],
            "?d": [
              "arg1"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ c }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ d }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't go to a {{ d }} from here.",
                "no_exit_to"
              ],
              [
                "You are already in the {{ d }}.",
                "going_to_current_room"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
          "epistemic": true,
          "pragmatic": true,
          "explanation": "To VERB is to move through space, especially to a place.",
          "type_name": "go"
        },
        {
          "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
          "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "You consider yourself done.",
          "asp": "",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To VERB is to end the game.",
          "type_name": "done"
        },
        {
          "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ],
            "?e": [
              "arg1"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ e }} is not an entity. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "Your inventory is not an entity. (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "{{ arg1_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to observe or inspect carefully.",
          "type_name": "examine"
        },
        {
          "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to inspect a room.",
          "type_name": "look"
        }
      ],
      "room_definitions": [
        {
          "repr_str": "ram",
          "exit_targets": [
            "atoust",
            "stingly"
          ],
          "max_connections": 1,
          "type_name": "ram"
        },
        {
          "repr_str": "stingly",
          "exit_targets": [
            "ram"
          ],
          "max_connections": 3,
          "type_name": "stingly"
        },
        {
          "repr_str": "atoust",
          "exit_targets": [
            "stingly",
            "iscum"
          ],
          "max_connections": 2,
          "type_name": "atoust"
        },
        {
          "repr_str": "iscum",
          "exit_targets": [
            "atoust",
            "stingly",
            "ram"
          ],
          "max_connections": 2,
          "type_name": "iscum"
        }
      ],
      "entity_definitions": [
        {
          "repr_str": "astable",
          "traits": [
            "preciny_able"
          ],
          "standard_locations": [
            "stingly",
            "iscum"
          ],
          "type_name": "astable"
        },
        {
          "repr_str": "omante",
          "traits": [
            "preciny_able"
          ],
          "standard_locations": [
            "ram"
          ],
          "type_name": "omante"
        },
        {
          "repr_str": "rot",
          "traits": [
            "lotta_able",
            "preciny_able"
          ],
          "standard_locations": [
            "iscum",
            "atoust"
          ],
          "type_name": "rot"
        },
        {
          "repr_str": "lonon",
          "traits": [
            "lotta_able",
            "padery_able"
          ],
          "standard_locations": [
            "iscum"
          ],
          "type_name": "lonon"
        },
        {
          "repr_str": "ishing",
          "traits": [
            "lotta_able",
            "preciny_able"
          ],
          "standard_locations": [
            "iscum",
            "stingly"
          ],
          "type_name": "ishing"
        },
        {
          "repr_str": "hirry",
          "traits": [
            "lotta_able"
          ],
          "standard_locations": [
            "ram",
            "iscum"
          ],
          "type_name": "hirry"
        },
        {
          "repr_str": "tisof",
          "traits": [
            "lotta_able"
          ],
          "standard_locations": [
            "iscum"
          ],
          "type_name": "tisof"
        },
        {
          "repr_str": "torhy",
          "traits": [
            "padery_able",
            "preciny_able"
          ],
          "standard_locations": [
            "iscum"
          ],
          "type_name": "torhy"
        },
        {
          "repr_str": "ilitid",
          "traits": [
            "preciny_able",
            "lotta_able"
          ],
          "standard_locations": [
            "stingly"
          ],
          "type_name": "ilitid"
        },
        {
          "repr_str": "rialiced",
          "traits": [
            "padery_able"
          ],
          "standard_locations": [
            "ram",
            "atoust"
          ],
          "type_name": "rialiced"
        },
        {
          "repr_str": "you",
          "traits": [],
          "hidden": true,
          "type_name": "player"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "inventory"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "floor"
        }
      ],
      "domain_definitions": [
        {
          "domain_id": "new_words",
          "types": {
            "room": [
              "ram",
              "stingly",
              "atoust",
              "iscum"
            ],
            "entity": [
              "player",
              "inventory",
              "floor",
              "astable",
              "omante",
              "rot",
              "lonon",
              "ishing",
              "hirry",
              "tisof",
              "torhy",
              "ilitid",
              "rialiced",
              "player",
              "inventory",
              "floor"
            ],
            "preciny_able": [
              "astable",
              "omante",
              "rot",
              "ishing",
              "torhy",
              "ilitid"
            ],
            "lotta_able": [
              "rot",
              "lonon",
              "ishing",
              "hirry",
              "tisof",
              "ilitid"
            ],
            "padery_able": [
              "lonon",
              "torhy",
              "rialiced"
            ]
          },
          "predicates": [
            {
              "predicate_id": "preciny",
              "variable": "e",
              "mutability": "preciny_able"
            },
            {
              "predicate_id": "lotta",
              "variable": "e",
              "mutability": "lotta_able"
            },
            {
              "predicate_id": "gumary",
              "variable": "e",
              "mutability": "lotta_able"
            },
            {
              "predicate_id": "padery",
              "variable": "e",
              "mutability": "padery_able"
            },
            {
              "predicate_id": "antally",
              "variable": "e",
              "mutability": "padery_able"
            },
            {
              "predicate_id": "helum",
              "variable": "e",
              "mutability": "padery_able"
            }
          ]
        }
      ],
      "bench_turn_limit": 50,
      "prompt_template_set": "new-words_created"
    },
    {
      "adventure_type": "new-words_created",
      "goal": "Make the hetle anird, the ioness opige and the rotont reforian.",
      "initial_state": [
        "at(venism1,routiced1)",
        "at(toxist1,guaced1)",
        "at(rotont1,atival1)",
        "at(herper1,atival1)",
        "at(equadish1,atival1)",
        "at(fervan1,atival1)",
        "at(thium1,atival1)",
        "at(hetle1,emingly1)",
        "at(attle1,routiced1)",
        "at(ioness1,atival1)",
        "at(player1,atival1)",
        "type(player1,player)",
        "type(ioness1,ioness)",
        "type(attle1,attle)",
        "type(hetle1,hetle)",
        "type(thium1,thium)",
        "type(fervan1,fervan)",
        "type(equadish1,equadish)",
        "type(herper1,herper)",
        "type(rotont1,rotont)",
        "type(toxist1,toxist)",
        "type(venism1,venism)",
        "room(routiced1,routiced)",
        "room(guaced1,guaced)",
        "room(emingly1,emingly)",
        "room(atival1,atival)",
        "anird(toxist1)",
        "anird(herper1)",
        "anird(equadish1)",
        "anird(fervan1)",
        "everce(thium1)",
        "everce(hetle1)",
        "reforian(venism1)",
        "cunad(thium1)",
        "cioty(rotont1)",
        "exit(routiced1,guaced1)",
        "exit(guaced1,routiced1)",
        "exit(emingly1,guaced1)",
        "exit(atival1,routiced1)",
        "exit(routiced1,atival1)",
        "exit(guaced1,emingly1)",
        "opige_able(ioness1)",
        "opige_able(attle1)",
        "opige_able(hetle1)",
        "opige_able(fervan1)",
        "opige_able(rotont1)",
        "opige_able(toxist1)",
        "anird_able(hetle1)",
        "anird_able(thium1)",
        "anird_able(fervan1)",
        "anird_able(equadish1)",
        "anird_able(herper1)",
        "anird_able(toxist1)",
        "reforian_able(thium1)",
        "reforian_able(rotont1)",
        "reforian_able(venism1)"
      ],
      "goal_state": [
        "opige(ioness1)",
        "anird(hetle1)",
        "reforian(rotont1)"
      ],
      "optimal_turns": 6,
      "optimal_solution": [
        [
          "mellum",
          "ioness1"
        ],
        [
          "clogery",
          "rotont1"
        ],
        [
          "go",
          "routiced1"
        ],
        [
          "go",
          "guaced1"
        ],
        [
          "go",
          "emingly1"
        ],
        [
          "ially",
          "hetle1"
        ]
      ],
      "optimal_commands": [
        "mellum ioness",
        "clogery rotont",
        "go routiced",
        "go guaced",
        "go emingly",
        "ially hetle"
      ],
      "action_definitions": [
        {
          "lark": "mellum: MELLUM thing\nMELLUM.1: \"mellum\" WS",
          "pddl": "(:action MELLUM\n    :parameters (?e - opige_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (opige ?e)\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not opige-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now opige.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To mellum is to make something opige_able opige.",
          "asp": "{ action_t(TURN,mellum,THING):at_t(TURN,THING,ROOM),opige_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nopige_t(TURN+1,THING) :- action_t(TURN,mellum,THING).\nopige_t(TURN+1,THING) :- turn(TURN), opige_t(TURN,THING).",
          "type_name": "mellum"
        },
        {
          "lark": "upbes: UPBES thing\nUPBES.1: \"upbes\" WS",
          "pddl": "(:action UPBES\n    :parameters (?e - anird_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (anird ?e)\n        )\n    :effect (and\n        (everce ?e)\n        (not (anird ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not anird-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not anird.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now everce.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To upbes is to make something anird_able and anird be everce.",
          "asp": "{ action_t(TURN,upbes,THING):at_t(TURN,THING,ROOM),anird_able(THING),anird_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\neverce_t(TURN+1,THING) :- action_t(TURN,upbes,THING).\nanird_t(TURN+1,THING) :- turn(TURN), anird_t(TURN,THING), not action_t(TURN,upbes,THING).",
          "type_name": "upbes"
        },
        {
          "lark": "ially: IALLY thing\nIALLY.1: \"ially\" WS",
          "pddl": "(:action IALLY\n    :parameters (?e - anird_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (everce ?e)\n        )\n    :effect (and\n        (anird ?e)\n        (not (everce ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not anird-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not everce.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now anird.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To ially is to make something anird_able and everce be anird.",
          "asp": "{ action_t(TURN,ially,THING):at_t(TURN,THING,ROOM),anird_able(THING),everce_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nanird_t(TURN+1,THING) :- action_t(TURN,ially,THING).\neverce_t(TURN+1,THING) :- turn(TURN), everce_t(TURN,THING), not action_t(TURN,ially,THING).",
          "type_name": "ially"
        },
        {
          "lark": "onser: ONSER thing\nONSER.1: \"onser\" WS",
          "pddl": "(:action ONSER\n    :parameters (?e - reforian_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (reforian ?e)\n        )\n    :effect (and\n        (cunad ?e)\n        (not (reforian ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not reforian-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not reforian.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now cunad.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To onser is to make something reforian_able and reforian be cunad.",
          "asp": "{ action_t(TURN,onser,THING):at_t(TURN,THING,ROOM),reforian_able(THING),reforian_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\ncunad_t(TURN+1,THING) :- action_t(TURN,onser,THING).\nreforian_t(TURN+1,THING) :- turn(TURN), reforian_t(TURN,THING), not action_t(TURN,onser,THING).",
          "type_name": "onser"
        },
        {
          "lark": "ellous: ELLOUS thing\nELLOUS.1: \"ellous\" WS",
          "pddl": "(:action ELLOUS\n    :parameters (?e - reforian_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (cunad ?e)\n        )\n    :effect (and\n        (cioty ?e)\n        (not (cunad ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not reforian-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not cunad.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now cioty.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To ellous is to make something reforian_able and cunad be cioty.",
          "asp": "{ action_t(TURN,ellous,THING):at_t(TURN,THING,ROOM),reforian_able(THING),cunad_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\ncioty_t(TURN+1,THING) :- action_t(TURN,ellous,THING).\ncunad_t(TURN+1,THING) :- turn(TURN), cunad_t(TURN,THING), not action_t(TURN,ellous,THING).",
          "type_name": "ellous"
        },
        {
          "lark": "clogery: CLOGERY thing\nCLOGERY.1: \"clogery\" WS",
          "pddl": "(:action CLOGERY\n    :parameters (?e - reforian_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (cioty ?e)\n        )\n    :effect (and\n        (reforian ?e)\n        (not (cioty ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not reforian-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not cioty.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now reforian.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To clogery is to make something reforian_able and cioty be reforian.",
          "asp": "{ action_t(TURN,clogery,THING):at_t(TURN,THING,ROOM),reforian_able(THING),cioty_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nreforian_t(TURN+1,THING) :- action_t(TURN,clogery,THING).\ncioty_t(TURN+1,THING) :- turn(TURN), cioty_t(TURN,THING), not action_t(TURN,clogery,THING).",
          "type_name": "clogery"
        },
        {
          "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
          "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
          "pddl_parameter_mapping": {
            "?c": [
              "current_player_room"
            ],
            "?d": [
              "arg1"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ c }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ d }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't go to a {{ d }} from here.",
                "no_exit_to"
              ],
              [
                "You are already in the {{ d }}.",
                "going_to_current_room"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
          "epistemic": true,
          "pragmatic": true,
          "explanation": "To VERB is to move through space, especially to a place.",
          "type_name": "go"
        },
        {
          "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
          "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "You consider yourself done.",
          "asp": "",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To VERB is to end the game.",
          "type_name": "done"
        },
        {
          "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ],
            "?e": [
              "arg1"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ e }} is not an entity. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "Your inventory is not an entity. (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "{{ arg1_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to observe or inspect carefully.",
          "type_name": "examine"
        },
        {
          "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to inspect a room.",
          "type_name": "look"
        }
      ],
      "room_definitions": [
        {
          "repr_str": "routiced",
          "exit_targets": [
            "emingly",
            "guaced"
          ],
          "max_connections": 1,
          "type_name": "routiced"
        },
        {
          "repr_str": "guaced",
          "exit_targets": [
            "routiced"
          ],
          "max_connections": 3,
          "type_name": "guaced"
        },
        {
          "repr_str": "emingly",
          "exit_targets": [
            "guaced",
            "atival"
          ],
          "max_connections": 2,
          "type_name": "emingly"
        },
        {
          "repr_str": "atival",
          "exit_targets": [
            "emingly",
            "guaced",
            "routiced"
          ],
          "max_connections": 2,
          "type_name": "atival"
        }
      ],
      "entity_definitions": [
        {
          "repr_str": "ioness",
          "traits": [
            "opige_able"
          ],
          "standard_locations": [
            "guaced",
            "atival"
          ],
          "type_name": "ioness"
        },
        {
          "repr_str": "attle",
          "traits": [
            "opige_able"
          ],
          "standard_locations": [
            "routiced"
          ],
          "type_name": "attle"
        },
        {
          "repr_str": "hetle",
          "traits": [
            "anird_able",
            "opige_able"
          ],
          "standard_locations": [
            "atival",
            "emingly"
          ],
          "type_name": "hetle"
        },
        {
          "repr_str": "thium",
          "traits": [
            "anird_able",
            "reforian_able"
          ],
          "standard_locations": [
            "atival"
          ],
          "type_name": "thium"
        },
        {
          "repr_str": "fervan",
          "traits": [
            "anird_able",
            "opige_able"
          ],
          "standard_locations": [
            "atival",
            "guaced"
          ],
          "type_name": "fervan"
        },
        {
          "repr_str": "equadish",
          "traits": [
            "anird_able"
          ],
          "standard_locations": [
            "routiced",
            "atival"
          ],
          "type_name": "equadish"
        },
        {
          "repr_str": "herper",
          "traits": [
            "anird_able"
          ],
          "standard_locations": [
            "atival"
          ],
          "type_name": "herper"
        },
        {
          "repr_str": "rotont",
          "traits": [
            "reforian_able",
            "opige_able"
          ],
          "standard_locations": [
            "atival"
          ],
          "type_name": "rotont"
        },
        {
          "repr_str": "toxist",
          "traits": [
            "opige_able",
            "anird_able"
          ],
          "standard_locations": [
            "guaced"
          ],
          "type_name": "toxist"
        },
        {
          "repr_str": "venism",
          "traits": [
            "reforian_able"
          ],
          "standard_locations": [
            "routiced",
            "emingly"
          ],
          "type_name": "venism"
        },
        {
          "repr_str": "you",
          "traits": [],
          "hidden": true,
          "type_name": "player"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "inventory"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "floor"
        }
      ],
      "domain_definitions": [
        {
          "domain_id": "new_words",
          "types": {
            "room": [
              "routiced",
              "guaced",
              "emingly",
              "atival"
            ],
            "entity": [
              "player",
              "inventory",
              "floor",
              "ioness",
              "attle",
              "hetle",
              "thium",
              "fervan",
              "equadish",
              "herper",
              "rotont",
              "toxist",
              "venism",
              "player",
              "inventory",
              "floor"
            ],
            "opige_able": [
              "ioness",
              "attle",
              "hetle",
              "fervan",
              "rotont",
              "toxist"
            ],
            "anird_able": [
              "hetle",
              "thium",
              "fervan",
              "equadish",
              "herper",
              "toxist"
            ],
            "reforian_able": [
              "thium",
              "rotont",
              "venism"
            ]
          },
          "predicates": [
            {
              "predicate_id": "opige",
              "variable": "e",
              "mutability": "opige_able"
            },
            {
              "predicate_id": "anird",
              "variable": "e",
              "mutability": "anird_able"
            },
            {
              "predicate_id": "everce",
              "variable": "e",
              "mutability": "anird_able"
            },
            {
              "predicate_id": "reforian",
              "variable": "e",
              "mutability": "reforian_able"
            },
            {
              "predicate_id": "cunad",
              "variable": "e",
              "mutability": "reforian_able"
            },
            {
              "predicate_id": "cioty",
              "variable": "e",
              "mutability": "reforian_able"
            }
          ]
        }
      ],
      "bench_turn_limit": 50,
      "prompt_template_set": "new-words_created"
    },
    {
      "adventure_type": "new-words_created",
      "goal": "Make the chophal permity, the hooiced nionian and the nousion nophyle.",
      "initial_state": [
        "at(ditain1,itink1)",
        "at(ridism1,ambint1)",
        "at(hooiced1,hydroft1)",
        "at(glogly1,hydroft1)",
        "at(gicalio1,hydroft1)",
        "at(eleniced1,hydroft1)",
        "at(alloger1,hydroft1)",
        "at(nousion1,pledle1)",
        "at(matiorm1,itink1)",
        "at(chophal1,hydroft1)",
        "at(player1,hydroft1)",
        "type(player1,player)",
        "type(chophal1,chophal)",
        "type(matiorm1,matiorm)",
        "type(nousion1,nousion)",
        "type(alloger1,alloger)",
        "type(eleniced1,eleniced)",
        "type(gicalio1,gicalio)",
        "type(glogly1,glogly)",
        "type(hooiced1,hooiced)",
        "type(ridism1,ridism)",
        "type(ditain1,ditain)",
        "room(itink1,itink)",
        "room(ambint1,ambint)",
        "room(pledle1,pledle)",
        "room(hydroft1,hydroft)",
        "nophyle(ridism1)",
        "nophyle(glogly1)",
        "nophyle(gicalio1)",
        "nophyle(eleniced1)",
        "tursotic(alloger1)",
        "tursotic(nousion1)",
        "nionian(ditain1)",
        "irmanty(alloger1)",
        "scalike(hooiced1)",
        "exit(itink1,ambint1)",
        "exit(ambint1,itink1)",
        "exit(pledle1,ambint1)",
        "exit(hydroft1,itink1)",
        "exit(itink1,hydroft1)",
        "exit(ambint1,pledle1)",
        "permity_able(chophal1)",
        "permity_able(matiorm1)",
        "permity_able(nousion1)",
        "permity_able(eleniced1)",
        "permity_able(hooiced1)",
        "permity_able(ridism1)",
        "nophyle_able(nousion1)",
        "nophyle_able(alloger1)",
        "nophyle_able(eleniced1)",
        "nophyle_able(gicalio1)",
        "nophyle_able(glogly1)",
        "nophyle_able(ridism1)",
        "nionian_able(alloger1)",
        "nionian_able(hooiced1)",
        "nionian_able(ditain1)"
      ],
      "goal_state": [
        "permity(chophal1)",
        "nophyle(nousion1)",
        "nionian(hooiced1)"
      ],
      "optimal_turns": 6,
      "optimal_solution": [
        [
          "athemb",
          "chophal1"
        ],
        [
          "arimic",
          "hooiced1"
        ],
        [
          "go",
          "itink1"
        ],
        [
          "go",
          "ambint1"
        ],
        [
          "go",
          "pledle1"
        ],
        [
          "altric",
          "nousion1"
        ]
      ],
      "optimal_commands": [
        "athemb chophal",
        "arimic hooiced",
        "go itink",
        "go ambint",
        "go pledle",
        "altric nousion"
      ],
      "action_definitions": [
        {
          "lark": "athemb: ATHEMB thing\nATHEMB.1: \"athemb\" WS",
          "pddl": "(:action ATHEMB\n    :parameters (?e - permity_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (permity ?e)\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not permity-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now permity.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To athemb is to make something permity_able permity.",
          "asp": "{ action_t(TURN,athemb,THING):at_t(TURN,THING,ROOM),permity_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\npermity_t(TURN+1,THING) :- action_t(TURN,athemb,THING).\npermity_t(TURN+1,THING) :- turn(TURN), permity_t(TURN,THING).",
          "type_name": "athemb"
        },
        {
          "lark": "abluty: ABLUTY thing\nABLUTY.1: \"abluty\" WS",
          "pddl": "(:action ABLUTY\n    :parameters (?e - nophyle_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (nophyle ?e)\n        )\n    :effect (and\n        (tursotic ?e)\n        (not (nophyle ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not nophyle-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not nophyle.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now tursotic.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To abluty is to make something nophyle_able and nophyle be tursotic.",
          "asp": "{ action_t(TURN,abluty,THING):at_t(TURN,THING,ROOM),nophyle_able(THING),nophyle_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\ntursotic_t(TURN+1,THING) :- action_t(TURN,abluty,THING).\nnophyle_t(TURN+1,THING) :- turn(TURN), nophyle_t(TURN,THING), not action_t(TURN,abluty,THING).",
          "type_name": "abluty"
        },
        {
          "lark": "altric: ALTRIC thing\nALTRIC.1: \"altric\" WS",
          "pddl": "(:action ALTRIC\n    :parameters (?e - nophyle_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (tursotic ?e)\n        )\n    :effect (and\n        (nophyle ?e)\n        (not (tursotic ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not nophyle-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not tursotic.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now nophyle.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To altric is to make something nophyle_able and tursotic be nophyle.",
          "asp": "{ action_t(TURN,altric,THING):at_t(TURN,THING,ROOM),nophyle_able(THING),tursotic_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nnophyle_t(TURN+1,THING) :- action_t(TURN,altric,THING).\ntursotic_t(TURN+1,THING) :- turn(TURN), tursotic_t(TURN,THING), not action_t(TURN,altric,THING).",
          "type_name": "altric"
        },
        {
          "lark": "uningne: UNINGNE thing\nUNINGNE.1: \"uningne\" WS",
          "pddl": "(:action UNINGNE\n    :parameters (?e - nionian_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (nionian ?e)\n        )\n    :effect (and\n        (irmanty ?e)\n        (not (nionian ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not nionian-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not nionian.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now irmanty.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To uningne is to make something nionian_able and nionian be irmanty.",
          "asp": "{ action_t(TURN,uningne,THING):at_t(TURN,THING,ROOM),nionian_able(THING),nionian_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nirmanty_t(TURN+1,THING) :- action_t(TURN,uningne,THING).\nnionian_t(TURN+1,THING) :- turn(TURN), nionian_t(TURN,THING), not action_t(TURN,uningne,THING).",
          "type_name": "uningne"
        },
        {
          "lark": "polotit: POLOTIT thing\nPOLOTIT.1: \"polotit\" WS",
          "pddl": "(:action POLOTIT\n    :parameters (?e - nionian_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (irmanty ?e)\n        )\n    :effect (and\n        (scalike ?e)\n        (not (irmanty ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not nionian-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not irmanty.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now scalike.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To polotit is to make something nionian_able and irmanty be scalike.",
          "asp": "{ action_t(TURN,polotit,THING):at_t(TURN,THING,ROOM),nionian_able(THING),irmanty_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nscalike_t(TURN+1,THING) :- action_t(TURN,polotit,THING).\nirmanty_t(TURN+1,THING) :- turn(TURN), irmanty_t(TURN,THING), not action_t(TURN,polotit,THING).",
          "type_name": "polotit"
        },
        {
          "lark": "arimic: ARIMIC thing\nARIMIC.1: \"arimic\" WS",
          "pddl": "(:action ARIMIC\n    :parameters (?e - nionian_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (scalike ?e)\n        )\n    :effect (and\n        (nionian ?e)\n        (not (scalike ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not nionian-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not scalike.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now nionian.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To arimic is to make something nionian_able and scalike be nionian.",
          "asp": "{ action_t(TURN,arimic,THING):at_t(TURN,THING,ROOM),nionian_able(THING),scalike_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nnionian_t(TURN+1,THING) :- action_t(TURN,arimic,THING).\nscalike_t(TURN+1,THING) :- turn(TURN), scalike_t(TURN,THING), not action_t(TURN,arimic,THING).",
          "type_name": "arimic"
        },
        {
          "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
          "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
          "pddl_parameter_mapping": {
            "?c": [
              "current_player_room"
            ],
            "?d": [
              "arg1"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ c }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ d }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't go to a {{ d }} from here.",
                "no_exit_to"
              ],
              [
                "You are already in the {{ d }}.",
                "going_to_current_room"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
          "epistemic": true,
          "pragmatic": true,
          "explanation": "To VERB is to move through space, especially to a place.",
          "type_name": "go"
        },
        {
          "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
          "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "You consider yourself done.",
          "asp": "",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To VERB is to end the game.",
          "type_name": "done"
        },
        {
          "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ],
            "?e": [
              "arg1"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ e }} is not an entity. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "Your inventory is not an entity. (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "{{ arg1_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to observe or inspect carefully.",
          "type_name": "examine"
        },
        {
          "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to inspect a room.",
          "type_name": "look"
        }
      ],
      "room_definitions": [
        {
          "repr_str": "itink",
          "exit_targets": [
            "pledle",
            "ambint"
          ],
          "max_connections": 1,
          "type_name": "itink"
        },
        {
          "repr_str": "ambint",
          "exit_targets": [
            "itink"
          ],
          "max_connections": 3,
          "type_name": "ambint"
        },
        {
          "repr_str": "pledle",
          "exit_targets": [
            "ambint",
            "hydroft"
          ],
          "max_connections": 2,
          "type_name": "pledle"
        },
        {
          "repr_str": "hydroft",
          "exit_targets": [
            "pledle",
            "ambint",
            "itink"
          ],
          "max_connections": 2,
          "type_name": "hydroft"
        }
      ],
      "entity_definitions": [
        {
          "repr_str": "chophal",
          "traits": [
            "permity_able"
          ],
          "standard_locations": [
            "ambint",
            "hydroft"
          ],
          "type_name": "chophal"
        },
        {
          "repr_str": "matiorm",
          "traits": [
            "permity_able"
          ],
          "standard_locations": [
            "itink"
          ],
          "type_name": "matiorm"
        },
        {
          "repr_str": "nousion",
          "traits": [
            "nophyle_able",
            "permity_able"
          ],
          "standard_locations": [
            "hydroft",
            "pledle"
          ],
          "type_name": "nousion"
        },
        {
          "repr_str": "alloger",
          "traits": [
            "nophyle_able",
            "nionian_able"
          ],
          "standard_locations": [
            "hydroft"
          ],
          "type_name": "alloger"
        },
        {
          "repr_str": "eleniced",
          "traits": [
            "nophyle_able",
            "permity_able"
          ],
          "standard_locations": [
            "hydroft",
            "ambint"
          ],
          "type_name": "eleniced"
        },
        {
          "repr_str": "gicalio",
          "traits": [
            "nophyle_able"
          ],
          "standard_locations": [
            "itink",
            "hydroft"
          ],
          "type_name": "gicalio"
        },
        {
          "repr_str": "glogly",
          "traits": [
            "nophyle_able"
          ],
          "standard_locations": [
            "hydroft"
          ],
          "type_name": "glogly"
        },
        {
          "repr_str": "hooiced",
          "traits": [
            "nionian_able",
            "permity_able"
          ],
          "standard_locations": [
            "hydroft"
          ],
          "type_name": "hooiced"
        },
        {
          "repr_str": "ridism",
          "traits": [
            "permity_able",
            "nophyle_able"
          ],
          "standard_locations": [
            "ambint"
          ],
          "type_name": "ridism"
        },
        {
          "repr_str": "ditain",
          "traits": [
            "nionian_able"
          ],
          "standard_locations": [
            "itink",
            "pledle"
          ],
          "type_name": "ditain"
        },
        {
          "repr_str": "you",
          "traits": [],
          "hidden": true,
          "type_name": "player"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "inventory"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "floor"
        }
      ],
      "domain_definitions": [
        {
          "domain_id": "new_words",
          "types": {
            "room": [
              "itink",
              "ambint",
              "pledle",
              "hydroft"
            ],
            "entity": [
              "player",
              "inventory",
              "floor",
              "chophal",
              "matiorm",
              "nousion",
              "alloger",
              "eleniced",
              "gicalio",
              "glogly",
              "hooiced",
              "ridism",
              "ditain",
              "player",
              "inventory",
              "floor"
            ],
            "permity_able": [
              "chophal",
              "matiorm",
              "nousion",
              "eleniced",
              "hooiced",
              "ridism"
            ],
            "nophyle_able": [
              "nousion",
              "alloger",
              "eleniced",
              "gicalio",
              "glogly",
              "ridism"
            ],
            "nionian_able": [
              "alloger",
              "hooiced",
              "ditain"
            ]
          },
          "predicates": [
            {
              "predicate_id": "permity",
              "variable": "e",
              "mutability": "permity_able"
            },
            {
              "predicate_id": "nophyle",
              "variable": "e",
              "mutability": "nophyle_able"
            },
            {
              "predicate_id": "tursotic",
              "variable": "e",
              "mutability": "nophyle_able"
            },
            {
              "predicate_id": "nionian",
              "variable": "e",
              "mutability": "nionian_able"
            },
            {
              "predicate_id": "irmanty",
              "variable": "e",
              "mutability": "nionian_able"
            },
            {
              "predicate_id": "scalike",
              "variable": "e",
              "mutability": "nionian_able"
            }
          ]
        }
      ],
      "bench_turn_limit": 50,
      "prompt_template_set": "new-words_created"
    },
    {
      "adventure_type": "new-words_created",
      "goal": "Make the oubiced ecastic, the prachon dedulag and the mindly ropile.",
      "initial_state": [
        "at(eriant1,conader1)",
        "at(tationsh1,onable1)",
        "at(mindly1,sinark1)",
        "at(ionity1,sinark1)",
        "at(epteria1,sinark1)",
        "at(uncepist1,sinark1)",
        "at(clednee1,sinark1)",
        "at(oubiced1,aterve1)",
        "at(ickle1,conader1)",
        "at(prachon1,sinark1)",
        "at(player1,sinark1)",
        "type(player1,player)",
        "type(prachon1,prachon)",
        "type(ickle1,ickle)",
        "type(oubiced1,oubiced)",
        "type(clednee1,clednee)",
        "type(uncepist1,uncepist)",
        "type(epteria1,epteria)",
        "type(ionity1,ionity)",
        "type(mindly1,mindly)",
        "type(tationsh1,tationsh)",
        "type(eriant1,eriant)",
        "room(conader1,conader)",
        "room(onable1,onable)",
        "room(aterve1,aterve)",
        "room(sinark1,sinark)",
        "ecastic(tationsh1)",
        "ecastic(ionity1)",
        "ecastic(epteria1)",
        "ecastic(uncepist1)",
        "phothipy(clednee1)",
        "phothipy(oubiced1)",
        "ropile(eriant1)",
        "fuster(clednee1)",
        "rancal(mindly1)",
        "exit(conader1,onable1)",
        "exit(onable1,conader1)",
        "exit(aterve1,onable1)",
        "exit(sinark1,conader1)",
        "exit(conader1,sinark1)",
        "exit(onable1,aterve1)",
        "dedulag_able(prachon1)",
        "dedulag_able(ickle1)",
        "dedulag_able(oubiced1)",
        "dedulag_able(uncepist1)",
        "dedulag_able(mindly1)",
        "dedulag_able(tationsh1)",
        "ecastic_able(oubiced1)",
        "ecastic_able(clednee1)",
        "ecastic_able(uncepist1)",
        "ecastic_able(epteria1)",
        "ecastic_able(ionity1)",
        "ecastic_able(tationsh1)",
        "ropile_able(clednee1)",
        "ropile_able(mindly1)",
        "ropile_able(eriant1)"
      ],
      "goal_state": [
        "dedulag(prachon1)",
        "ecastic(oubiced1)",
        "ropile(mindly1)"
      ],
      "optimal_turns": 6,
      "optimal_solution": [
        [
          "spidene",
          "prachon1"
        ],
        [
          "pnestay",
          "mindly1"
        ],
        [
          "go",
          "conader1"
        ],
        [
          "go",
          "onable1"
        ],
        [
          "go",
          "aterve1"
        ],
        [
          "atifory",
          "oubiced1"
        ]
      ],
      "optimal_commands": [
        "spidene prachon",
        "pnestay mindly",
        "go conader",
        "go onable",
        "go aterve",
        "atifory oubiced"
      ],
      "action_definitions": [
        {
          "lark": "spidene: SPIDENE thing\nSPIDENE.1: \"spidene\" WS",
          "pddl": "(:action SPIDENE\n    :parameters (?e - dedulag_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (dedulag ?e)\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not dedulag-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now dedulag.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To spidene is to make something dedulag_able dedulag.",
          "asp": "{ action_t(TURN,spidene,THING):at_t(TURN,THING,ROOM),dedulag_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\ndedulag_t(TURN+1,THING) :- action_t(TURN,spidene,THING).\ndedulag_t(TURN+1,THING) :- turn(TURN), dedulag_t(TURN,THING).",
          "type_name": "spidene"
        },
        {
          "lark": "adcry: ADCRY thing\nADCRY.1: \"adcry\" WS",
          "pddl": "(:action ADCRY\n    :parameters (?e - ecastic_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (ecastic ?e)\n        )\n    :effect (and\n        (phothipy ?e)\n        (not (ecastic ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not ecastic-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not ecastic.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now phothipy.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To adcry is to make something ecastic_able and ecastic be phothipy.",
          "asp": "{ action_t(TURN,adcry,THING):at_t(TURN,THING,ROOM),ecastic_able(THING),ecastic_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nphothipy_t(TURN+1,THING) :- action_t(TURN,adcry,THING).\necastic_t(TURN+1,THING) :- turn(TURN), ecastic_t(TURN,THING), not action_t(TURN,adcry,THING).",
          "type_name": "adcry"
        },
        {
          "lark": "atifory: ATIFORY thing\nATIFORY.1: \"atifory\" WS",
          "pddl": "(:action ATIFORY\n    :parameters (?e - ecastic_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (phothipy ?e)\n        )\n    :effect (and\n        (ecastic ?e)\n        (not (phothipy ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not ecastic-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not phothipy.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now ecastic.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To atifory is to make something ecastic_able and phothipy be ecastic.",
          "asp": "{ action_t(TURN,atifory,THING):at_t(TURN,THING,ROOM),ecastic_able(THING),phothipy_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\necastic_t(TURN+1,THING) :- action_t(TURN,atifory,THING).\nphothipy_t(TURN+1,THING) :- turn(TURN), phothipy_t(TURN,THING), not action_t(TURN,atifory,THING).",
          "type_name": "atifory"
        },
        {
          "lark": "alful: ALFUL thing\nALFUL.1: \"alful\" WS",
          "pddl": "(:action ALFUL\n    :parameters (?e - ropile_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (ropile ?e)\n        )\n    :effect (and\n        (fuster ?e)\n        (not (ropile ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not ropile-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not ropile.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now fuster.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To alful is to make something ropile_able and ropile be fuster.",
          "asp": "{ action_t(TURN,alful,THING):at_t(TURN,THING,ROOM),ropile_able(THING),ropile_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nfuster_t(TURN+1,THING) :- action_t(TURN,alful,THING).\nropile_t(TURN+1,THING) :- turn(TURN), ropile_t(TURN,THING), not action_t(TURN,alful,THING).",
          "type_name": "alful"
        },
        {
          "lark": "propress: PROPRESS thing\nPROPRESS.1: \"propress\" WS",
          "pddl": "(:action PROPRESS\n    :parameters (?e - ropile_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (fuster ?e)\n        )\n    :effect (and\n        (rancal ?e)\n        (not (fuster ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not ropile-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not fuster.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now rancal.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To propress is to make something ropile_able and fuster be rancal.",
          "asp": "{ action_t(TURN,propress,THING):at_t(TURN,THING,ROOM),ropile_able(THING),fuster_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nrancal_t(TURN+1,THING) :- action_t(TURN,propress,THING).\nfuster_t(TURN+1,THING) :- turn(TURN), fuster_t(TURN,THING), not action_t(TURN,propress,THING).",
          "type_name": "propress"
        },
        {
          "lark": "pnestay: PNESTAY thing\nPNESTAY.1: \"pnestay\" WS",
          "pddl": "(:action PNESTAY\n    :parameters (?e - ropile_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (rancal ?e)\n        )\n    :effect (and\n        (ropile ?e)\n        (not (rancal ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not ropile-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not rancal.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now ropile.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To pnestay is to make something ropile_able and rancal be ropile.",
          "asp": "{ action_t(TURN,pnestay,THING):at_t(TURN,THING,ROOM),ropile_able(THING),rancal_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nropile_t(TURN+1,THING) :- action_t(TURN,pnestay,THING).\nrancal_t(TURN+1,THING) :- turn(TURN), rancal_t(TURN,THING), not action_t(TURN,pnestay,THING).",
          "type_name": "pnestay"
        },
        {
          "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
          "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
          "pddl_parameter_mapping": {
            "?c": [
              "current_player_room"
            ],
            "?d": [
              "arg1"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ c }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ d }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't go to a {{ d }} from here.",
                "no_exit_to"
              ],
              [
                "You are already in the {{ d }}.",
                "going_to_current_room"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
          "epistemic": true,
          "pragmatic": true,
          "explanation": "To VERB is to move through space, especially to a place.",
          "type_name": "go"
        },
        {
          "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
          "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "You consider yourself done.",
          "asp": "",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To VERB is to end the game.",
          "type_name": "done"
        },
        {
          "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ],
            "?e": [
              "arg1"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ e }} is not an entity. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "Your inventory is not an entity. (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "{{ arg1_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to observe or inspect carefully.",
          "type_name": "examine"
        },
        {
          "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to inspect a room.",
          "type_name": "look"
        }
      ],
      "room_definitions": [
        {
          "repr_str": "conader",
          "exit_targets": [
            "aterve",
            "onable"
          ],
          "max_connections": 1,
          "type_name": "conader"
        },
        {
          "repr_str": "onable",
          "exit_targets": [
            "conader"
          ],
          "max_connections": 3,
          "type_name": "onable"
        },
        {
          "repr_str": "aterve",
          "exit_targets": [
            "onable",
            "sinark"
          ],
          "max_connections": 2,
          "type_name": "aterve"
        },
        {
          "repr_str": "sinark",
          "exit_targets": [
            "aterve",
            "onable",
            "conader"
          ],
          "max_connections": 2,
          "type_name": "sinark"
        }
      ],
      "entity_definitions": [
        {
          "repr_str": "prachon",
          "traits": [
            "dedulag_able"
          ],
          "standard_locations": [
            "onable",
            "sinark"
          ],
          "type_name": "prachon"
        },
        {
          "repr_str": "ickle",
          "traits": [
            "dedulag_able"
          ],
          "standard_locations": [
            "conader"
          ],
          "type_name": "ickle"
        },
        {
          "repr_str": "oubiced",
          "traits": [
            "ecastic_able",
            "dedulag_able"
          ],
          "standard_locations": [
            "sinark",
            "aterve"
          ],
          "type_name": "oubiced"
        },
        {
          "repr_str": "clednee",
          "traits": [
            "ecastic_able",
            "ropile_able"
          ],
          "standard_locations": [
            "sinark"
          ],
          "type_name": "clednee"
        },
        {
          "repr_str": "uncepist",
          "traits": [
            "ecastic_able",
            "dedulag_able"
          ],
          "standard_locations": [
            "sinark",
            "onable"
          ],
          "type_name": "uncepist"
        },
        {
          "repr_str": "epteria",
          "traits": [
            "ecastic_able"
          ],
          "standard_locations": [
            "conader",
            "sinark"
          ],
          "type_name": "epteria"
        },
        {
          "repr_str": "ionity",
          "traits": [
            "ecastic_able"
          ],
          "standard_locations": [
            "sinark"
          ],
          "type_name": "ionity"
        },
        {
          "repr_str": "mindly",
          "traits": [
            "ropile_able",
            "dedulag_able"
          ],
          "standard_locations": [
            "sinark"
          ],
          "type_name": "mindly"
        },
        {
          "repr_str": "tationsh",
          "traits": [
            "dedulag_able",
            "ecastic_able"
          ],
          "standard_locations": [
            "onable"
          ],
          "type_name": "tationsh"
        },
        {
          "repr_str": "eriant",
          "traits": [
            "ropile_able"
          ],
          "standard_locations": [
            "conader",
            "aterve"
          ],
          "type_name": "eriant"
        },
        {
          "repr_str": "you",
          "traits": [],
          "hidden": true,
          "type_name": "player"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "inventory"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "floor"
        }
      ],
      "domain_definitions": [
        {
          "domain_id": "new_words",
          "types": {
            "room": [
              "conader",
              "onable",
              "aterve",
              "sinark"
            ],
            "entity": [
              "player",
              "inventory",
              "floor",
              "prachon",
              "ickle",
              "oubiced",
              "clednee",
              "uncepist",
              "epteria",
              "ionity",
              "mindly",
              "tationsh",
              "eriant",
              "player",
              "inventory",
              "floor"
            ],
            "dedulag_able": [
              "prachon",
              "ickle",
              "oubiced",
              "uncepist",
              "mindly",
              "tationsh"
            ],
            "ecastic_able": [
              "oubiced",
              "clednee",
              "uncepist",
              "epteria",
              "ionity",
              "tationsh"
            ],
            "ropile_able": [
              "clednee",
              "mindly",
              "eriant"
            ]
          },
          "predicates": [
            {
              "predicate_id": "dedulag",
              "variable": "e",
              "mutability": "dedulag_able"
            },
            {
              "predicate_id": "ecastic",
              "variable": "e",
              "mutability": "ecastic_able"
            },
            {
              "predicate_id": "phothipy",
              "variable": "e",
              "mutability": "ecastic_able"
            },
            {
              "predicate_id": "ropile",
              "variable": "e",
              "mutability": "ropile_able"
            },
            {
              "predicate_id": "fuster",
              "variable": "e",
              "mutability": "ropile_able"
            },
            {
              "predicate_id": "rancal",
              "variable": "e",
              "mutability": "ropile_able"
            }
          ]
        }
      ],
      "bench_turn_limit": 50,
      "prompt_template_set": "new-words_created"
    },
    {
      "adventure_type": "new-words_created",
      "goal": "Make the pholoiced connone, the aeval proggiced and the rheably exsem.",
      "initial_state": [
        "at(ousles1,erove1)",
        "at(roofid1,omenan1)",
        "at(pholoiced1,peroury1)",
        "at(shromen1,peroury1)",
        "at(eical1,peroury1)",
        "at(oidess1,peroury1)",
        "at(versch1,peroury1)",
        "at(rheably1,apsing1)",
        "at(soest1,erove1)",
        "at(aeval1,peroury1)",
        "at(player1,peroury1)",
        "type(player1,player)",
        "type(aeval1,aeval)",
        "type(soest1,soest)",
        "type(rheably1,rheably)",
        "type(versch1,versch)",
        "type(oidess1,oidess)",
        "type(eical1,eical)",
        "type(shromen1,shromen)",
        "type(pholoiced1,pholoiced)",
        "type(roofid1,roofid)",
        "type(ousles1,ousles)",
        "room(erove1,erove)",
        "room(omenan1,omenan)",
        "room(apsing1,apsing)",
        "room(peroury1,peroury)",
        "exsem(roofid1)",
        "exsem(shromen1)",
        "exsem(eical1)",
        "exsem(oidess1)",
        "thighth(versch1)",
        "thighth(rheably1)",
        "connone(ousles1)",
        "dingnessy(versch1)",
        "alomeny(pholoiced1)",
        "exit(erove1,omenan1)",
        "exit(omenan1,erove1)",
        "exit(apsing1,omenan1)",
        "exit(peroury1,erove1)",
        "exit(erove1,peroury1)",
        "exit(omenan1,apsing1)",
        "proggiced_able(aeval1)",
        "proggiced_able(soest1)",
        "proggiced_able(rheably1)",
        "proggiced_able(oidess1)",
        "proggiced_able(pholoiced1)",
        "proggiced_able(roofid1)",
        "exsem_able(rheably1)",
        "exsem_able(versch1)",
        "exsem_able(oidess1)",
        "exsem_able(eical1)",
        "exsem_able(shromen1)",
        "exsem_able(roofid1)",
        "connone_able(versch1)",
        "connone_able(pholoiced1)",
        "connone_able(ousles1)"
      ],
      "goal_state": [
        "proggiced(aeval1)",
        "exsem(rheably1)",
        "connone(pholoiced1)"
      ],
      "optimal_turns": 6,
      "optimal_solution": [
        [
          "udial",
          "aeval1"
        ],
        [
          "aterous",
          "pholoiced1"
        ],
        [
          "go",
          "erove1"
        ],
        [
          "go",
          "omenan1"
        ],
        [
          "go",
          "apsing1"
        ],
        [
          "unmastic",
          "rheably1"
        ]
      ],
      "optimal_commands": [
        "udial aeval",
        "aterous pholoiced",
        "go erove",
        "go omenan",
        "go apsing",
        "unmastic rheably"
      ],
      "action_definitions": [
        {
          "lark": "udial: UDIAL thing\nUDIAL.1: \"udial\" WS",
          "pddl": "(:action UDIAL\n    :parameters (?e - proggiced_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (proggiced ?e)\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not proggiced-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now proggiced.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To udial is to make something proggiced_able proggiced.",
          "asp": "{ action_t(TURN,udial,THING):at_t(TURN,THING,ROOM),proggiced_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nproggiced_t(TURN+1,THING) :- action_t(TURN,udial,THING).\nproggiced_t(TURN+1,THING) :- turn(TURN), proggiced_t(TURN,THING).",
          "type_name": "udial"
        },
        {
          "lark": "ivess: IVESS thing\nIVESS.1: \"ivess\" WS",
          "pddl": "(:action IVESS\n    :parameters (?e - exsem_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (exsem ?e)\n        )\n    :effect (and\n        (thighth ?e)\n        (not (exsem ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not exsem-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not exsem.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now thighth.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To ivess is to make something exsem_able and exsem be thighth.",
          "asp": "{ action_t(TURN,ivess,THING):at_t(TURN,THING,ROOM),exsem_able(THING),exsem_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nthighth_t(TURN+1,THING) :- action_t(TURN,ivess,THING).\nexsem_t(TURN+1,THING) :- turn(TURN), exsem_t(TURN,THING), not action_t(TURN,ivess,THING).",
          "type_name": "ivess"
        },
        {
          "lark": "unmastic: UNMASTIC thing\nUNMASTIC.1: \"unmastic\" WS",
          "pddl": "(:action UNMASTIC\n    :parameters (?e - exsem_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (thighth ?e)\n        )\n    :effect (and\n        (exsem ?e)\n        (not (thighth ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not exsem-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not thighth.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now exsem.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To unmastic is to make something exsem_able and thighth be exsem.",
          "asp": "{ action_t(TURN,unmastic,THING):at_t(TURN,THING,ROOM),exsem_able(THING),thighth_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nexsem_t(TURN+1,THING) :- action_t(TURN,unmastic,THING).\nthighth_t(TURN+1,THING) :- turn(TURN), thighth_t(TURN,THING), not action_t(TURN,unmastic,THING).",
          "type_name": "unmastic"
        },
        {
          "lark": "ceorid: CEORID thing\nCEORID.1: \"ceorid\" WS",
          "pddl": "(:action CEORID\n    :parameters (?e - connone_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (connone ?e)\n        )\n    :effect (and\n        (dingnessy ?e)\n        (not (connone ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not connone-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not connone.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now dingnessy.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To ceorid is to make something connone_able and connone be dingnessy.",
          "asp": "{ action_t(TURN,ceorid,THING):at_t(TURN,THING,ROOM),connone_able(THING),connone_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\ndingnessy_t(TURN+1,THING) :- action_t(TURN,ceorid,THING).\nconnone_t(TURN+1,THING) :- turn(TURN), connone_t(TURN,THING), not action_t(TURN,ceorid,THING).",
          "type_name": "ceorid"
        },
        {
          "lark": "ingnus: INGNUS thing\nINGNUS.1: \"ingnus\" WS",
          "pddl": "(:action INGNUS\n    :parameters (?e - connone_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (dingnessy ?e)\n        )\n    :effect (and\n        (alomeny ?e)\n        (not (dingnessy ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not connone-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not dingnessy.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now alomeny.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To ingnus is to make something connone_able and dingnessy be alomeny.",
          "asp": "{ action_t(TURN,ingnus,THING):at_t(TURN,THING,ROOM),connone_able(THING),dingnessy_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nalomeny_t(TURN+1,THING) :- action_t(TURN,ingnus,THING).\ndingnessy_t(TURN+1,THING) :- turn(TURN), dingnessy_t(TURN,THING), not action_t(TURN,ingnus,THING).",
          "type_name": "ingnus"
        },
        {
          "lark": "aterous: ATEROUS thing\nATEROUS.1: \"aterous\" WS",
          "pddl": "(:action ATEROUS\n    :parameters (?e - connone_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (alomeny ?e)\n        )\n    :effect (and\n        (connone ?e)\n        (not (alomeny ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not connone-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not alomeny.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now connone.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To aterous is to make something connone_able and alomeny be connone.",
          "asp": "{ action_t(TURN,aterous,THING):at_t(TURN,THING,ROOM),connone_able(THING),alomeny_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nconnone_t(TURN+1,THING) :- action_t(TURN,aterous,THING).\nalomeny_t(TURN+1,THING) :- turn(TURN), alomeny_t(TURN,THING), not action_t(TURN,aterous,THING).",
          "type_name": "aterous"
        },
        {
          "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
          "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
          "pddl_parameter_mapping": {
            "?c": [
              "current_player_room"
            ],
            "?d": [
              "arg1"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ c }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ d }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't go to a {{ d }} from here.",
                "no_exit_to"
              ],
              [
                "You are already in the {{ d }}.",
                "going_to_current_room"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
          "epistemic": true,
          "pragmatic": true,
          "explanation": "To VERB is to move through space, especially to a place.",
          "type_name": "go"
        },
        {
          "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
          "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "You consider yourself done.",
          "asp": "",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To VERB is to end the game.",
          "type_name": "done"
        },
        {
          "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ],
            "?e": [
              "arg1"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ e }} is not an entity. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "Your inventory is not an entity. (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "{{ arg1_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to observe or inspect carefully.",
          "type_name": "examine"
        },
        {
          "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to inspect a room.",
          "type_name": "look"
        }
      ],
      "room_definitions": [
        {
          "repr_str": "erove",
          "exit_targets": [
            "apsing",
            "omenan"
          ],
          "max_connections": 1,
          "type_name": "erove"
        },
        {
          "repr_str": "omenan",
          "exit_targets": [
            "erove"
          ],
          "max_connections": 3,
          "type_name": "omenan"
        },
        {
          "repr_str": "apsing",
          "exit_targets": [
            "omenan",
            "peroury"
          ],
          "max_connections": 2,
          "type_name": "apsing"
        },
        {
          "repr_str": "peroury",
          "exit_targets": [
            "apsing",
            "omenan",
            "erove"
          ],
          "max_connections": 2,
          "type_name": "peroury"
        }
      ],
      "entity_definitions": [
        {
          "repr_str": "aeval",
          "traits": [
            "proggiced_able"
          ],
          "standard_locations": [
            "omenan",
            "peroury"
          ],
          "type_name": "aeval"
        },
        {
          "repr_str": "soest",
          "traits": [
            "proggiced_able"
          ],
          "standard_locations": [
            "erove"
          ],
          "type_name": "soest"
        },
        {
          "repr_str": "rheably",
          "traits": [
            "exsem_able",
            "proggiced_able"
          ],
          "standard_locations": [
            "peroury",
            "apsing"
          ],
          "type_name": "rheably"
        },
        {
          "repr_str": "versch",
          "traits": [
            "exsem_able",
            "connone_able"
          ],
          "standard_locations": [
            "peroury"
          ],
          "type_name": "versch"
        },
        {
          "repr_str": "oidess",
          "traits": [
            "exsem_able",
            "proggiced_able"
          ],
          "standard_locations": [
            "peroury",
            "omenan"
          ],
          "type_name": "oidess"
        },
        {
          "repr_str": "eical",
          "traits": [
            "exsem_able"
          ],
          "standard_locations": [
            "erove",
            "peroury"
          ],
          "type_name": "eical"
        },
        {
          "repr_str": "shromen",
          "traits": [
            "exsem_able"
          ],
          "standard_locations": [
            "peroury"
          ],
          "type_name": "shromen"
        },
        {
          "repr_str": "pholoiced",
          "traits": [
            "connone_able",
            "proggiced_able"
          ],
          "standard_locations": [
            "peroury"
          ],
          "type_name": "pholoiced"
        },
        {
          "repr_str": "roofid",
          "traits": [
            "proggiced_able",
            "exsem_able"
          ],
          "standard_locations": [
            "omenan"
          ],
          "type_name": "roofid"
        },
        {
          "repr_str": "ousles",
          "traits": [
            "connone_able"
          ],
          "standard_locations": [
            "erove",
            "apsing"
          ],
          "type_name": "ousles"
        },
        {
          "repr_str": "you",
          "traits": [],
          "hidden": true,
          "type_name": "player"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "inventory"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "floor"
        }
      ],
      "domain_definitions": [
        {
          "domain_id": "new_words",
          "types": {
            "room": [
              "erove",
              "omenan",
              "apsing",
              "peroury"
            ],
            "entity": [
              "player",
              "inventory",
              "floor",
              "aeval",
              "soest",
              "rheably",
              "versch",
              "oidess",
              "eical",
              "shromen",
              "pholoiced",
              "roofid",
              "ousles",
              "player",
              "inventory",
              "floor"
            ],
            "proggiced_able": [
              "aeval",
              "soest",
              "rheably",
              "oidess",
              "pholoiced",
              "roofid"
            ],
            "exsem_able": [
              "rheably",
              "versch",
              "oidess",
              "eical",
              "shromen",
              "roofid"
            ],
            "connone_able": [
              "versch",
              "pholoiced",
              "ousles"
            ]
          },
          "predicates": [
            {
              "predicate_id": "proggiced",
              "variable": "e",
              "mutability": "proggiced_able"
            },
            {
              "predicate_id": "exsem",
              "variable": "e",
              "mutability": "exsem_able"
            },
            {
              "predicate_id": "thighth",
              "variable": "e",
              "mutability": "exsem_able"
            },
            {
              "predicate_id": "connone",
              "variable": "e",
              "mutability": "connone_able"
            },
            {
              "predicate_id": "dingnessy",
              "variable": "e",
              "mutability": "connone_able"
            },
            {
              "predicate_id": "alomeny",
              "variable": "e",
              "mutability": "connone_able"
            }
          ]
        }
      ],
      "bench_turn_limit": 50,
      "prompt_template_set": "new-words_created"
    },
    {
      "adventure_type": "new-words_created",
      "goal": "Make the utist hetioner, the icess tubilly and the anonaticed ippet.",
      "initial_state": [
        "at(obilard1,oidemat1)",
        "at(robve1,chlove1)",
        "at(icess1,endroust1)",
        "at(lableve1,endroust1)",
        "at(stoaced1,endroust1)",
        "at(atedist1,endroust1)",
        "at(coepticed1,endroust1)",
        "at(anonaticed1,menzinee1)",
        "at(linkly1,oidemat1)",
        "at(utist1,endroust1)",
        "at(player1,endroust1)",
        "type(player1,player)",
        "type(utist1,utist)",
        "type(linkly1,linkly)",
        "type(anonaticed1,anonaticed)",
        "type(coepticed1,coepticed)",
        "type(atedist1,atedist)",
        "type(stoaced1,stoaced)",
        "type(lableve1,lableve)",
        "type(icess1,icess)",
        "type(robve1,robve)",
        "type(obilard1,obilard)",
        "room(oidemat1,oidemat)",
        "room(chlove1,chlove)",
        "room(menzinee1,menzinee)",
        "room(endroust1,endroust)",
        "ippet(robve1)",
        "ippet(lableve1)",
        "ippet(stoaced1)",
        "ippet(atedist1)",
        "hoxopal(coepticed1)",
        "hoxopal(anonaticed1)",
        "tubilly(obilard1)",
        "phorpiced(coepticed1)",
        "alidow(icess1)",
        "exit(oidemat1,chlove1)",
        "exit(chlove1,oidemat1)",
        "exit(menzinee1,chlove1)",
        "exit(endroust1,oidemat1)",
        "exit(oidemat1,endroust1)",
        "exit(chlove1,menzinee1)",
        "hetioner_able(utist1)",
        "hetioner_able(linkly1)",
        "hetioner_able(anonaticed1)",
        "hetioner_able(atedist1)",
        "hetioner_able(icess1)",
        "hetioner_able(robve1)",
        "ippet_able(anonaticed1)",
        "ippet_able(coepticed1)",
        "ippet_able(atedist1)",
        "ippet_able(stoaced1)",
        "ippet_able(lableve1)",
        "ippet_able(robve1)",
        "tubilly_able(coepticed1)",
        "tubilly_able(icess1)",
        "tubilly_able(obilard1)"
      ],
      "goal_state": [
        "hetioner(utist1)",
        "ippet(anonaticed1)",
        "tubilly(icess1)"
      ],
      "optimal_turns": 6,
      "optimal_solution": [
        [
          "oryter",
          "utist1"
        ],
        [
          "urseum",
          "icess1"
        ],
        [
          "go",
          "oidemat1"
        ],
        [
          "go",
          "chlove1"
        ],
        [
          "go",
          "menzinee1"
        ],
        [
          "tritioush",
          "anonaticed1"
        ]
      ],
      "optimal_commands": [
        "oryter utist",
        "urseum icess",
        "go oidemat",
        "go chlove",
        "go menzinee",
        "tritioush anonaticed"
      ],
      "action_definitions": [
        {
          "lark": "oryter: ORYTER thing\nORYTER.1: \"oryter\" WS",
          "pddl": "(:action ORYTER\n    :parameters (?e - hetioner_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (hetioner ?e)\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not hetioner-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now hetioner.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To oryter is to make something hetioner_able hetioner.",
          "asp": "{ action_t(TURN,oryter,THING):at_t(TURN,THING,ROOM),hetioner_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nhetioner_t(TURN+1,THING) :- action_t(TURN,oryter,THING).\nhetioner_t(TURN+1,THING) :- turn(TURN), hetioner_t(TURN,THING).",
          "type_name": "oryter"
        },
        {
          "lark": "atheris: ATHERIS thing\nATHERIS.1: \"atheris\" WS",
          "pddl": "(:action ATHERIS\n    :parameters (?e - ippet_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (ippet ?e)\n        )\n    :effect (and\n        (hoxopal ?e)\n        (not (ippet ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not ippet-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not ippet.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now hoxopal.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To atheris is to make something ippet_able and ippet be hoxopal.",
          "asp": "{ action_t(TURN,atheris,THING):at_t(TURN,THING,ROOM),ippet_able(THING),ippet_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nhoxopal_t(TURN+1,THING) :- action_t(TURN,atheris,THING).\nippet_t(TURN+1,THING) :- turn(TURN), ippet_t(TURN,THING), not action_t(TURN,atheris,THING).",
          "type_name": "atheris"
        },
        {
          "lark": "tritioush: TRITIOUSH thing\nTRITIOUSH.1: \"tritioush\" WS",
          "pddl": "(:action TRITIOUSH\n    :parameters (?e - ippet_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (hoxopal ?e)\n        )\n    :effect (and\n        (ippet ?e)\n        (not (hoxopal ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not ippet-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not hoxopal.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now ippet.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To tritioush is to make something ippet_able and hoxopal be ippet.",
          "asp": "{ action_t(TURN,tritioush,THING):at_t(TURN,THING,ROOM),ippet_able(THING),hoxopal_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nippet_t(TURN+1,THING) :- action_t(TURN,tritioush,THING).\nhoxopal_t(TURN+1,THING) :- turn(TURN), hoxopal_t(TURN,THING), not action_t(TURN,tritioush,THING).",
          "type_name": "tritioush"
        },
        {
          "lark": "jolene: JOLENE thing\nJOLENE.1: \"jolene\" WS",
          "pddl": "(:action JOLENE\n    :parameters (?e - tubilly_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (tubilly ?e)\n        )\n    :effect (and\n        (phorpiced ?e)\n        (not (tubilly ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not tubilly-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not tubilly.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now phorpiced.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To jolene is to make something tubilly_able and tubilly be phorpiced.",
          "asp": "{ action_t(TURN,jolene,THING):at_t(TURN,THING,ROOM),tubilly_able(THING),tubilly_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nphorpiced_t(TURN+1,THING) :- action_t(TURN,jolene,THING).\ntubilly_t(TURN+1,THING) :- turn(TURN), tubilly_t(TURN,THING), not action_t(TURN,jolene,THING).",
          "type_name": "jolene"
        },
        {
          "lark": "amyoid: AMYOID thing\nAMYOID.1: \"amyoid\" WS",
          "pddl": "(:action AMYOID\n    :parameters (?e - tubilly_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (phorpiced ?e)\n        )\n    :effect (and\n        (alidow ?e)\n        (not (phorpiced ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not tubilly-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not phorpiced.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now alidow.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To amyoid is to make something tubilly_able and phorpiced be alidow.",
          "asp": "{ action_t(TURN,amyoid,THING):at_t(TURN,THING,ROOM),tubilly_able(THING),phorpiced_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nalidow_t(TURN+1,THING) :- action_t(TURN,amyoid,THING).\nphorpiced_t(TURN+1,THING) :- turn(TURN), phorpiced_t(TURN,THING), not action_t(TURN,amyoid,THING).",
          "type_name": "amyoid"
        },
        {
          "lark": "urseum: URSEUM thing\nURSEUM.1: \"urseum\" WS",
          "pddl": "(:action URSEUM\n    :parameters (?e - tubilly_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (alidow ?e)\n        )\n    :effect (and\n        (tubilly ?e)\n        (not (alidow ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not tubilly-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not alidow.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now tubilly.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To urseum is to make something tubilly_able and alidow be tubilly.",
          "asp": "{ action_t(TURN,urseum,THING):at_t(TURN,THING,ROOM),tubilly_able(THING),alidow_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\ntubilly_t(TURN+1,THING) :- action_t(TURN,urseum,THING).\nalidow_t(TURN+1,THING) :- turn(TURN), alidow_t(TURN,THING), not action_t(TURN,urseum,THING).",
          "type_name": "urseum"
        },
        {
          "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
          "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
          "pddl_parameter_mapping": {
            "?c": [
              "current_player_room"
            ],
            "?d": [
              "arg1"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ c }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ d }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't go to a {{ d }} from here.",
                "no_exit_to"
              ],
              [
                "You are already in the {{ d }}.",
                "going_to_current_room"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
          "epistemic": true,
          "pragmatic": true,
          "explanation": "To VERB is to move through space, especially to a place.",
          "type_name": "go"
        },
        {
          "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
          "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "You consider yourself done.",
          "asp": "",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To VERB is to end the game.",
          "type_name": "done"
        },
        {
          "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ],
            "?e": [
              "arg1"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ e }} is not an entity. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "Your inventory is not an entity. (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "{{ arg1_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to observe or inspect carefully.",
          "type_name": "examine"
        },
        {
          "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to inspect a room.",
          "type_name": "look"
        }
      ],
      "room_definitions": [
        {
          "repr_str": "oidemat",
          "exit_targets": [
            "menzinee",
            "chlove"
          ],
          "max_connections": 1,
          "type_name": "oidemat"
        },
        {
          "repr_str": "chlove",
          "exit_targets": [
            "oidemat"
          ],
          "max_connections": 3,
          "type_name": "chlove"
        },
        {
          "repr_str": "menzinee",
          "exit_targets": [
            "chlove",
            "endroust"
          ],
          "max_connections": 2,
          "type_name": "menzinee"
        },
        {
          "repr_str": "endroust",
          "exit_targets": [
            "menzinee",
            "chlove",
            "oidemat"
          ],
          "max_connections": 2,
          "type_name": "endroust"
        }
      ],
      "entity_definitions": [
        {
          "repr_str": "utist",
          "traits": [
            "hetioner_able"
          ],
          "standard_locations": [
            "chlove",
            "endroust"
          ],
          "type_name": "utist"
        },
        {
          "repr_str": "linkly",
          "traits": [
            "hetioner_able"
          ],
          "standard_locations": [
            "oidemat"
          ],
          "type_name": "linkly"
        },
        {
          "repr_str": "anonaticed",
          "traits": [
            "ippet_able",
            "hetioner_able"
          ],
          "standard_locations": [
            "endroust",
            "menzinee"
          ],
          "type_name": "anonaticed"
        },
        {
          "repr_str": "coepticed",
          "traits": [
            "ippet_able",
            "tubilly_able"
          ],
          "standard_locations": [
            "endroust"
          ],
          "type_name": "coepticed"
        },
        {
          "repr_str": "atedist",
          "traits": [
            "ippet_able",
            "hetioner_able"
          ],
          "standard_locations": [
            "endroust",
            "chlove"
          ],
          "type_name": "atedist"
        },
        {
          "repr_str": "stoaced",
          "traits": [
            "ippet_able"
          ],
          "standard_locations": [
            "oidemat",
            "endroust"
          ],
          "type_name": "stoaced"
        },
        {
          "repr_str": "lableve",
          "traits": [
            "ippet_able"
          ],
          "standard_locations": [
            "endroust"
          ],
          "type_name": "lableve"
        },
        {
          "repr_str": "icess",
          "traits": [
            "tubilly_able",
            "hetioner_able"
          ],
          "standard_locations": [
            "endroust"
          ],
          "type_name": "icess"
        },
        {
          "repr_str": "robve",
          "traits": [
            "hetioner_able",
            "ippet_able"
          ],
          "standard_locations": [
            "chlove"
          ],
          "type_name": "robve"
        },
        {
          "repr_str": "obilard",
          "traits": [
            "tubilly_able"
          ],
          "standard_locations": [
            "oidemat",
            "menzinee"
          ],
          "type_name": "obilard"
        },
        {
          "repr_str": "you",
          "traits": [],
          "hidden": true,
          "type_name": "player"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "inventory"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "floor"
        }
      ],
      "domain_definitions": [
        {
          "domain_id": "new_words",
          "types": {
            "room": [
              "oidemat",
              "chlove",
              "menzinee",
              "endroust"
            ],
            "entity": [
              "player",
              "inventory",
              "floor",
              "utist",
              "linkly",
              "anonaticed",
              "coepticed",
              "atedist",
              "stoaced",
              "lableve",
              "icess",
              "robve",
              "obilard",
              "player",
              "inventory",
              "floor"
            ],
            "hetioner_able": [
              "utist",
              "linkly",
              "anonaticed",
              "atedist",
              "icess",
              "robve"
            ],
            "ippet_able": [
              "anonaticed",
              "coepticed",
              "atedist",
              "stoaced",
              "lableve",
              "robve"
            ],
            "tubilly_able": [
              "coepticed",
              "icess",
              "obilard"
            ]
          },
          "predicates": [
            {
              "predicate_id": "hetioner",
              "variable": "e",
              "mutability": "hetioner_able"
            },
            {
              "predicate_id": "ippet",
              "variable": "e",
              "mutability": "ippet_able"
            },
            {
              "predicate_id": "hoxopal",
              "variable": "e",
              "mutability": "ippet_able"
            },
            {
              "predicate_id": "tubilly",
              "variable": "e",
              "mutability": "tubilly_able"
            },
            {
              "predicate_id": "phorpiced",
              "variable": "e",
              "mutability": "tubilly_able"
            },
            {
              "predicate_id": "alidow",
              "variable": "e",
              "mutability": "tubilly_able"
            }
          ]
        }
      ],
      "bench_turn_limit": 50,
      "prompt_template_set": "new-words_created"
    },
    {
      "adventure_type": "new-words_created",
      "goal": "Make the rimess horpler, the urermat ytoust and the loscred tibing.",
      "initial_state": [
        "at(ragmat1,gligiced1)",
        "at(entabul1,urgily1)",
        "at(loscred1,discroust1)",
        "at(suncente1,discroust1)",
        "at(eposper1,discroust1)",
        "at(hidist1,discroust1)",
        "at(conitity1,discroust1)",
        "at(rimess1,ibret1)",
        "at(thempary1,gligiced1)",
        "at(urermat1,discroust1)",
        "at(player1,discroust1)",
        "type(player1,player)",
        "type(urermat1,urermat)",
        "type(thempary1,thempary)",
        "type(rimess1,rimess)",
        "type(conitity1,conitity)",
        "type(hidist1,hidist)",
        "type(eposper1,eposper)",
        "type(suncente1,suncente)",
        "type(loscred1,loscred)",
        "type(entabul1,entabul)",
        "type(ragmat1,ragmat)",
        "room(gligiced1,gligiced)",
        "room(urgily1,urgily)",
        "room(ibret1,ibret)",
        "room(discroust1,discroust)",
        "horpler(entabul1)",
        "horpler(suncente1)",
        "horpler(eposper1)",
        "horpler(hidist1)",
        "suatocky(conitity1)",
        "suatocky(rimess1)",
        "tibing(ragmat1)",
        "orposee(conitity1)",
        "oanicky(loscred1)",
        "exit(gligiced1,urgily1)",
        "exit(urgily1,gligiced1)",
        "exit(ibret1,urgily1)",
        "exit(discroust1,gligiced1)",
        "exit(gligiced1,discroust1)",
        "exit(urgily1,ibret1)",
        "ytoust_able(urermat1)",
        "ytoust_able(thempary1)",
        "ytoust_able(rimess1)",
        "ytoust_able(hidist1)",
        "ytoust_able(loscred1)",
        "ytoust_able(entabul1)",
        "horpler_able(rimess1)",
        "horpler_able(conitity1)",
        "horpler_able(hidist1)",
        "horpler_able(eposper1)",
        "horpler_able(suncente1)",
        "horpler_able(entabul1)",
        "tibing_able(conitity1)",
        "tibing_able(loscred1)",
        "tibing_able(ragmat1)"
      ],
      "goal_state": [
        "ytoust(urermat1)",
        "horpler(rimess1)",
        "tibing(loscred1)"
      ],
      "optimal_turns": 6,
      "optimal_solution": [
        [
          "eredle",
          "urermat1"
        ],
        [
          "indiable",
          "loscred1"
        ],
        [
          "go",
          "gligiced1"
        ],
        [
          "go",
          "urgily1"
        ],
        [
          "go",
          "ibret1"
        ],
        [
          "phophous",
          "rimess1"
        ]
      ],
      "optimal_commands": [
        "eredle urermat",
        "indiable loscred",
        "go gligiced",
        "go urgily",
        "go ibret",
        "phophous rimess"
      ],
      "action_definitions": [
        {
          "lark": "eredle: EREDLE thing\nEREDLE.1: \"eredle\" WS",
          "pddl": "(:action EREDLE\n    :parameters (?e - ytoust_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (ytoust ?e)\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not ytoust-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now ytoust.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To eredle is to make something ytoust_able ytoust.",
          "asp": "{ action_t(TURN,eredle,THING):at_t(TURN,THING,ROOM),ytoust_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nytoust_t(TURN+1,THING) :- action_t(TURN,eredle,THING).\nytoust_t(TURN+1,THING) :- turn(TURN), ytoust_t(TURN,THING).",
          "type_name": "eredle"
        },
        {
          "lark": "unsibion: UNSIBION thing\nUNSIBION.1: \"unsibion\" WS",
          "pddl": "(:action UNSIBION\n    :parameters (?e - horpler_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (horpler ?e)\n        )\n    :effect (and\n        (suatocky ?e)\n        (not (horpler ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not horpler-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not horpler.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now suatocky.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To unsibion is to make something horpler_able and horpler be suatocky.",
          "asp": "{ action_t(TURN,unsibion,THING):at_t(TURN,THING,ROOM),horpler_able(THING),horpler_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nsuatocky_t(TURN+1,THING) :- action_t(TURN,unsibion,THING).\nhorpler_t(TURN+1,THING) :- turn(TURN), horpler_t(TURN,THING), not action_t(TURN,unsibion,THING).",
          "type_name": "unsibion"
        },
        {
          "lark": "phophous: PHOPHOUS thing\nPHOPHOUS.1: \"phophous\" WS",
          "pddl": "(:action PHOPHOUS\n    :parameters (?e - horpler_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (suatocky ?e)\n        )\n    :effect (and\n        (horpler ?e)\n        (not (suatocky ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not horpler-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not suatocky.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now horpler.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To phophous is to make something horpler_able and suatocky be horpler.",
          "asp": "{ action_t(TURN,phophous,THING):at_t(TURN,THING,ROOM),horpler_able(THING),suatocky_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nhorpler_t(TURN+1,THING) :- action_t(TURN,phophous,THING).\nsuatocky_t(TURN+1,THING) :- turn(TURN), suatocky_t(TURN,THING), not action_t(TURN,phophous,THING).",
          "type_name": "phophous"
        },
        {
          "lark": "isecin: ISECIN thing\nISECIN.1: \"isecin\" WS",
          "pddl": "(:action ISECIN\n    :parameters (?e - tibing_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (tibing ?e)\n        )\n    :effect (and\n        (orposee ?e)\n        (not (tibing ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not tibing-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not tibing.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now orposee.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To isecin is to make something tibing_able and tibing be orposee.",
          "asp": "{ action_t(TURN,isecin,THING):at_t(TURN,THING,ROOM),tibing_able(THING),tibing_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\norposee_t(TURN+1,THING) :- action_t(TURN,isecin,THING).\ntibing_t(TURN+1,THING) :- turn(TURN), tibing_t(TURN,THING), not action_t(TURN,isecin,THING).",
          "type_name": "isecin"
        },
        {
          "lark": "horehet: HOREHET thing\nHOREHET.1: \"horehet\" WS",
          "pddl": "(:action HOREHET\n    :parameters (?e - tibing_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (orposee ?e)\n        )\n    :effect (and\n        (oanicky ?e)\n        (not (orposee ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not tibing-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not orposee.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now oanicky.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To horehet is to make something tibing_able and orposee be oanicky.",
          "asp": "{ action_t(TURN,horehet,THING):at_t(TURN,THING,ROOM),tibing_able(THING),orposee_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\noanicky_t(TURN+1,THING) :- action_t(TURN,horehet,THING).\norposee_t(TURN+1,THING) :- turn(TURN), orposee_t(TURN,THING), not action_t(TURN,horehet,THING).",
          "type_name": "horehet"
        },
        {
          "lark": "indiable: INDIABLE thing\nINDIABLE.1: \"indiable\" WS",
          "pddl": "(:action INDIABLE\n    :parameters (?e - tibing_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (oanicky ?e)\n        )\n    :effect (and\n        (tibing ?e)\n        (not (oanicky ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not tibing-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not oanicky.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now tibing.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To indiable is to make something tibing_able and oanicky be tibing.",
          "asp": "{ action_t(TURN,indiable,THING):at_t(TURN,THING,ROOM),tibing_able(THING),oanicky_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\ntibing_t(TURN+1,THING) :- action_t(TURN,indiable,THING).\noanicky_t(TURN+1,THING) :- turn(TURN), oanicky_t(TURN,THING), not action_t(TURN,indiable,THING).",
          "type_name": "indiable"
        },
        {
          "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
          "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
          "pddl_parameter_mapping": {
            "?c": [
              "current_player_room"
            ],
            "?d": [
              "arg1"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ c }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ d }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't go to a {{ d }} from here.",
                "no_exit_to"
              ],
              [
                "You are already in the {{ d }}.",
                "going_to_current_room"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
          "epistemic": true,
          "pragmatic": true,
          "explanation": "To VERB is to move through space, especially to a place.",
          "type_name": "go"
        },
        {
          "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
          "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "You consider yourself done.",
          "asp": "",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To VERB is to end the game.",
          "type_name": "done"
        },
        {
          "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ],
            "?e": [
              "arg1"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ e }} is not an entity. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "Your inventory is not an entity. (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "{{ arg1_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to observe or inspect carefully.",
          "type_name": "examine"
        },
        {
          "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to inspect a room.",
          "type_name": "look"
        }
      ],
      "room_definitions": [
        {
          "repr_str": "gligiced",
          "exit_targets": [
            "ibret",
            "urgily"
          ],
          "max_connections": 1,
          "type_name": "gligiced"
        },
        {
          "repr_str": "urgily",
          "exit_targets": [
            "gligiced"
          ],
          "max_connections": 3,
          "type_name": "urgily"
        },
        {
          "repr_str": "ibret",
          "exit_targets": [
            "urgily",
            "discroust"
          ],
          "max_connections": 2,
          "type_name": "ibret"
        },
        {
          "repr_str": "discroust",
          "exit_targets": [
            "ibret",
            "urgily",
            "gligiced"
          ],
          "max_connections": 2,
          "type_name": "discroust"
        }
      ],
      "entity_definitions": [
        {
          "repr_str": "urermat",
          "traits": [
            "ytoust_able"
          ],
          "standard_locations": [
            "urgily",
            "discroust"
          ],
          "type_name": "urermat"
        },
        {
          "repr_str": "thempary",
          "traits": [
            "ytoust_able"
          ],
          "standard_locations": [
            "gligiced"
          ],
          "type_name": "thempary"
        },
        {
          "repr_str": "rimess",
          "traits": [
            "horpler_able",
            "ytoust_able"
          ],
          "standard_locations": [
            "discroust",
            "ibret"
          ],
          "type_name": "rimess"
        },
        {
          "repr_str": "conitity",
          "traits": [
            "horpler_able",
            "tibing_able"
          ],
          "standard_locations": [
            "discroust"
          ],
          "type_name": "conitity"
        },
        {
          "repr_str": "hidist",
          "traits": [
            "horpler_able",
            "ytoust_able"
          ],
          "standard_locations": [
            "discroust",
            "urgily"
          ],
          "type_name": "hidist"
        },
        {
          "repr_str": "eposper",
          "traits": [
            "horpler_able"
          ],
          "standard_locations": [
            "gligiced",
            "discroust"
          ],
          "type_name": "eposper"
        },
        {
          "repr_str": "suncente",
          "traits": [
            "horpler_able"
          ],
          "standard_locations": [
            "discroust"
          ],
          "type_name": "suncente"
        },
        {
          "repr_str": "loscred",
          "traits": [
            "tibing_able",
            "ytoust_able"
          ],
          "standard_locations": [
            "discroust"
          ],
          "type_name": "loscred"
        },
        {
          "repr_str": "entabul",
          "traits": [
            "ytoust_able",
            "horpler_able"
          ],
          "standard_locations": [
            "urgily"
          ],
          "type_name": "entabul"
        },
        {
          "repr_str": "ragmat",
          "traits": [
            "tibing_able"
          ],
          "standard_locations": [
            "gligiced",
            "ibret"
          ],
          "type_name": "ragmat"
        },
        {
          "repr_str": "you",
          "traits": [],
          "hidden": true,
          "type_name": "player"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "inventory"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "floor"
        }
      ],
      "domain_definitions": [
        {
          "domain_id": "new_words",
          "types": {
            "room": [
              "gligiced",
              "urgily",
              "ibret",
              "discroust"
            ],
            "entity": [
              "player",
              "inventory",
              "floor",
              "urermat",
              "thempary",
              "rimess",
              "conitity",
              "hidist",
              "eposper",
              "suncente",
              "loscred",
              "entabul",
              "ragmat",
              "player",
              "inventory",
              "floor"
            ],
            "ytoust_able": [
              "urermat",
              "thempary",
              "rimess",
              "hidist",
              "loscred",
              "entabul"
            ],
            "horpler_able": [
              "rimess",
              "conitity",
              "hidist",
              "eposper",
              "suncente",
              "entabul"
            ],
            "tibing_able": [
              "conitity",
              "loscred",
              "ragmat"
            ]
          },
          "predicates": [
            {
              "predicate_id": "ytoust",
              "variable": "e",
              "mutability": "ytoust_able"
            },
            {
              "predicate_id": "horpler",
              "variable": "e",
              "mutability": "horpler_able"
            },
            {
              "predicate_id": "suatocky",
              "variable": "e",
              "mutability": "horpler_able"
            },
            {
              "predicate_id": "tibing",
              "variable": "e",
              "mutability": "tibing_able"
            },
            {
              "predicate_id": "orposee",
              "variable": "e",
              "mutability": "tibing_able"
            },
            {
              "predicate_id": "oanicky",
              "variable": "e",
              "mutability": "tibing_able"
            }
          ]
        }
      ],
      "bench_turn_limit": 50,
      "prompt_template_set": "new-words_created"
    },
    {
      "adventure_type": "new-words_created",
      "goal": "Make the rakeer skenic, the asceles tinhal and the mituark mationymb.",
      "initial_state": [
        "at(mementiced1,trapseng1)",
        "at(untastion1,ammidiced1)",
        "at(mituark1,heccop1)",
        "at(otioct1,heccop1)",
        "at(inagness1,heccop1)",
        "at(horbact1,heccop1)",
        "at(ctaticed1,heccop1)",
        "at(rakeer1,nontroust1)",
        "at(cenotor1,trapseng1)",
        "at(asceles1,heccop1)",
        "at(player1,heccop1)",
        "type(player1,player)",
        "type(asceles1,asceles)",
        "type(cenotor1,cenotor)",
        "type(rakeer1,rakeer)",
        "type(ctaticed1,ctaticed)",
        "type(horbact1,horbact)",
        "type(inagness1,inagness)",
        "type(otioct1,otioct)",
        "type(mituark1,mituark)",
        "type(untastion1,untastion)",
        "type(mementiced1,mementiced)",
        "room(trapseng1,trapseng)",
        "room(ammidiced1,ammidiced)",
        "room(nontroust1,nontroust)",
        "room(heccop1,heccop)",
        "skenic(untastion1)",
        "skenic(otioct1)",
        "skenic(inagness1)",
        "skenic(horbact1)",
        "icarity(ctaticed1)",
        "icarity(rakeer1)",
        "mationymb(mementiced1)",
        "bactiogy(ctaticed1)",
        "trendol(mituark1)",
        "exit(trapseng1,ammidiced1)",
        "exit(ammidiced1,trapseng1)",
        "exit(nontroust1,ammidiced1)",
        "exit(heccop1,trapseng1)",
        "exit(trapseng1,heccop1)",
        "exit(ammidiced1,nontroust1)",
        "tinhal_able(asceles1)",
        "tinhal_able(cenotor1)",
        "tinhal_able(rakeer1)",
        "tinhal_able(horbact1)",
        "tinhal_able(mituark1)",
        "tinhal_able(untastion1)",
        "skenic_able(rakeer1)",
        "skenic_able(ctaticed1)",
        "skenic_able(horbact1)",
        "skenic_able(inagness1)",
        "skenic_able(otioct1)",
        "skenic_able(untastion1)",
        "mationymb_able(ctaticed1)",
        "mationymb_able(mituark1)",
        "mationymb_able(mementiced1)"
      ],
      "goal_state": [
        "tinhal(asceles1)",
        "skenic(rakeer1)",
        "mationymb(mituark1)"
      ],
      "optimal_turns": 6,
      "optimal_solution": [
        [
          "lophante",
          "asceles1"
        ],
        [
          "rhypnon",
          "mituark1"
        ],
        [
          "go",
          "trapseng1"
        ],
        [
          "go",
          "ammidiced1"
        ],
        [
          "go",
          "nontroust1"
        ],
        [
          "hoadve",
          "rakeer1"
        ]
      ],
      "optimal_commands": [
        "lophante asceles",
        "rhypnon mituark",
        "go trapseng",
        "go ammidiced",
        "go nontroust",
        "hoadve rakeer"
      ],
      "action_definitions": [
        {
          "lark": "lophante: LOPHANTE thing\nLOPHANTE.1: \"lophante\" WS",
          "pddl": "(:action LOPHANTE\n    :parameters (?e - tinhal_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (tinhal ?e)\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not tinhal-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now tinhal.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To lophante is to make something tinhal_able tinhal.",
          "asp": "{ action_t(TURN,lophante,THING):at_t(TURN,THING,ROOM),tinhal_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\ntinhal_t(TURN+1,THING) :- action_t(TURN,lophante,THING).\ntinhal_t(TURN+1,THING) :- turn(TURN), tinhal_t(TURN,THING).",
          "type_name": "lophante"
        },
        {
          "lark": "alitst: ALITST thing\nALITST.1: \"alitst\" WS",
          "pddl": "(:action ALITST\n    :parameters (?e - skenic_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (skenic ?e)\n        )\n    :effect (and\n        (icarity ?e)\n        (not (skenic ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not skenic-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not skenic.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now icarity.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To alitst is to make something skenic_able and skenic be icarity.",
          "asp": "{ action_t(TURN,alitst,THING):at_t(TURN,THING,ROOM),skenic_able(THING),skenic_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nicarity_t(TURN+1,THING) :- action_t(TURN,alitst,THING).\nskenic_t(TURN+1,THING) :- turn(TURN), skenic_t(TURN,THING), not action_t(TURN,alitst,THING).",
          "type_name": "alitst"
        },
        {
          "lark": "hoadve: HOADVE thing\nHOADVE.1: \"hoadve\" WS",
          "pddl": "(:action HOADVE\n    :parameters (?e - skenic_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (icarity ?e)\n        )\n    :effect (and\n        (skenic ?e)\n        (not (icarity ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not skenic-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not icarity.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now skenic.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To hoadve is to make something skenic_able and icarity be skenic.",
          "asp": "{ action_t(TURN,hoadve,THING):at_t(TURN,THING,ROOM),skenic_able(THING),icarity_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nskenic_t(TURN+1,THING) :- action_t(TURN,hoadve,THING).\nicarity_t(TURN+1,THING) :- turn(TURN), icarity_t(TURN,THING), not action_t(TURN,hoadve,THING).",
          "type_name": "hoadve"
        },
        {
          "lark": "ompous: OMPOUS thing\nOMPOUS.1: \"ompous\" WS",
          "pddl": "(:action OMPOUS\n    :parameters (?e - mationymb_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (mationymb ?e)\n        )\n    :effect (and\n        (bactiogy ?e)\n        (not (mationymb ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not mationymb-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not mationymb.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now bactiogy.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To ompous is to make something mationymb_able and mationymb be bactiogy.",
          "asp": "{ action_t(TURN,ompous,THING):at_t(TURN,THING,ROOM),mationymb_able(THING),mationymb_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nbactiogy_t(TURN+1,THING) :- action_t(TURN,ompous,THING).\nmationymb_t(TURN+1,THING) :- turn(TURN), mationymb_t(TURN,THING), not action_t(TURN,ompous,THING).",
          "type_name": "ompous"
        },
        {
          "lark": "ophabor: OPHABOR thing\nOPHABOR.1: \"ophabor\" WS",
          "pddl": "(:action OPHABOR\n    :parameters (?e - mationymb_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (bactiogy ?e)\n        )\n    :effect (and\n        (trendol ?e)\n        (not (bactiogy ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not mationymb-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not bactiogy.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now trendol.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To ophabor is to make something mationymb_able and bactiogy be trendol.",
          "asp": "{ action_t(TURN,ophabor,THING):at_t(TURN,THING,ROOM),mationymb_able(THING),bactiogy_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\ntrendol_t(TURN+1,THING) :- action_t(TURN,ophabor,THING).\nbactiogy_t(TURN+1,THING) :- turn(TURN), bactiogy_t(TURN,THING), not action_t(TURN,ophabor,THING).",
          "type_name": "ophabor"
        },
        {
          "lark": "rhypnon: RHYPNON thing\nRHYPNON.1: \"rhypnon\" WS",
          "pddl": "(:action RHYPNON\n    :parameters (?e - mationymb_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (trendol ?e)\n        )\n    :effect (and\n        (mationymb ?e)\n        (not (trendol ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not mationymb-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not trendol.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now mationymb.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To rhypnon is to make something mationymb_able and trendol be mationymb.",
          "asp": "{ action_t(TURN,rhypnon,THING):at_t(TURN,THING,ROOM),mationymb_able(THING),trendol_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nmationymb_t(TURN+1,THING) :- action_t(TURN,rhypnon,THING).\ntrendol_t(TURN+1,THING) :- turn(TURN), trendol_t(TURN,THING), not action_t(TURN,rhypnon,THING).",
          "type_name": "rhypnon"
        },
        {
          "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
          "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
          "pddl_parameter_mapping": {
            "?c": [
              "current_player_room"
            ],
            "?d": [
              "arg1"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ c }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ d }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't go to a {{ d }} from here.",
                "no_exit_to"
              ],
              [
                "You are already in the {{ d }}.",
                "going_to_current_room"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
          "epistemic": true,
          "pragmatic": true,
          "explanation": "To VERB is to move through space, especially to a place.",
          "type_name": "go"
        },
        {
          "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
          "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "You consider yourself done.",
          "asp": "",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To VERB is to end the game.",
          "type_name": "done"
        },
        {
          "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ],
            "?e": [
              "arg1"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ e }} is not an entity. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "Your inventory is not an entity. (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "{{ arg1_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to observe or inspect carefully.",
          "type_name": "examine"
        },
        {
          "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to inspect a room.",
          "type_name": "look"
        }
      ],
      "room_definitions": [
        {
          "repr_str": "trapseng",
          "exit_targets": [
            "nontroust",
            "ammidiced"
          ],
          "max_connections": 1,
          "type_name": "trapseng"
        },
        {
          "repr_str": "ammidiced",
          "exit_targets": [
            "trapseng"
          ],
          "max_connections": 3,
          "type_name": "ammidiced"
        },
        {
          "repr_str": "nontroust",
          "exit_targets": [
            "ammidiced",
            "heccop"
          ],
          "max_connections": 2,
          "type_name": "nontroust"
        },
        {
          "repr_str": "heccop",
          "exit_targets": [
            "nontroust",
            "ammidiced",
            "trapseng"
          ],
          "max_connections": 2,
          "type_name": "heccop"
        }
      ],
      "entity_definitions": [
        {
          "repr_str": "asceles",
          "traits": [
            "tinhal_able"
          ],
          "standard_locations": [
            "ammidiced",
            "heccop"
          ],
          "type_name": "asceles"
        },
        {
          "repr_str": "cenotor",
          "traits": [
            "tinhal_able"
          ],
          "standard_locations": [
            "trapseng"
          ],
          "type_name": "cenotor"
        },
        {
          "repr_str": "rakeer",
          "traits": [
            "skenic_able",
            "tinhal_able"
          ],
          "standard_locations": [
            "heccop",
            "nontroust"
          ],
          "type_name": "rakeer"
        },
        {
          "repr_str": "ctaticed",
          "traits": [
            "skenic_able",
            "mationymb_able"
          ],
          "standard_locations": [
            "heccop"
          ],
          "type_name": "ctaticed"
        },
        {
          "repr_str": "horbact",
          "traits": [
            "skenic_able",
            "tinhal_able"
          ],
          "standard_locations": [
            "heccop",
            "ammidiced"
          ],
          "type_name": "horbact"
        },
        {
          "repr_str": "inagness",
          "traits": [
            "skenic_able"
          ],
          "standard_locations": [
            "trapseng",
            "heccop"
          ],
          "type_name": "inagness"
        },
        {
          "repr_str": "otioct",
          "traits": [
            "skenic_able"
          ],
          "standard_locations": [
            "heccop"
          ],
          "type_name": "otioct"
        },
        {
          "repr_str": "mituark",
          "traits": [
            "mationymb_able",
            "tinhal_able"
          ],
          "standard_locations": [
            "heccop"
          ],
          "type_name": "mituark"
        },
        {
          "repr_str": "untastion",
          "traits": [
            "tinhal_able",
            "skenic_able"
          ],
          "standard_locations": [
            "ammidiced"
          ],
          "type_name": "untastion"
        },
        {
          "repr_str": "mementiced",
          "traits": [
            "mationymb_able"
          ],
          "standard_locations": [
            "trapseng",
            "nontroust"
          ],
          "type_name": "mementiced"
        },
        {
          "repr_str": "you",
          "traits": [],
          "hidden": true,
          "type_name": "player"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "inventory"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "floor"
        }
      ],
      "domain_definitions": [
        {
          "domain_id": "new_words",
          "types": {
            "room": [
              "trapseng",
              "ammidiced",
              "nontroust",
              "heccop"
            ],
            "entity": [
              "player",
              "inventory",
              "floor",
              "asceles",
              "cenotor",
              "rakeer",
              "ctaticed",
              "horbact",
              "inagness",
              "otioct",
              "mituark",
              "untastion",
              "mementiced",
              "player",
              "inventory",
              "floor"
            ],
            "tinhal_able": [
              "asceles",
              "cenotor",
              "rakeer",
              "horbact",
              "mituark",
              "untastion"
            ],
            "skenic_able": [
              "rakeer",
              "ctaticed",
              "horbact",
              "inagness",
              "otioct",
              "untastion"
            ],
            "mationymb_able": [
              "ctaticed",
              "mituark",
              "mementiced"
            ]
          },
          "predicates": [
            {
              "predicate_id": "tinhal",
              "variable": "e",
              "mutability": "tinhal_able"
            },
            {
              "predicate_id": "skenic",
              "variable": "e",
              "mutability": "skenic_able"
            },
            {
              "predicate_id": "icarity",
              "variable": "e",
              "mutability": "skenic_able"
            },
            {
              "predicate_id": "mationymb",
              "variable": "e",
              "mutability": "mationymb_able"
            },
            {
              "predicate_id": "bactiogy",
              "variable": "e",
              "mutability": "mationymb_able"
            },
            {
              "predicate_id": "trendol",
              "variable": "e",
              "mutability": "mationymb_able"
            }
          ]
        }
      ],
      "bench_turn_limit": 50,
      "prompt_template_set": "new-words_created"
    },
    {
      "adventure_type": "new-words_created",
      "goal": "Make the bintioust atilioned, the forotoly serhing and the retritt aurpher.",
      "initial_state": [
        "at(torifism1,rofflum1)",
        "at(sancyter1,iciante1)",
        "at(retritt1,realighy1)",
        "at(avirriced1,realighy1)",
        "at(iscolad1,realighy1)",
        "at(urafflag1,realighy1)",
        "at(shemood1,realighy1)",
        "at(bintioust1,llism1)",
        "at(harantal1,rofflum1)",
        "at(forotoly1,realighy1)",
        "at(player1,realighy1)",
        "type(player1,player)",
        "type(forotoly1,forotoly)",
        "type(harantal1,harantal)",
        "type(bintioust1,bintioust)",
        "type(shemood1,shemood)",
        "type(urafflag1,urafflag)",
        "type(iscolad1,iscolad)",
        "type(avirriced1,avirriced)",
        "type(retritt1,retritt)",
        "type(sancyter1,sancyter)",
        "type(torifism1,torifism)",
        "room(rofflum1,rofflum)",
        "room(iciante1,iciante)",
        "room(llism1,llism)",
        "room(realighy1,realighy)",
        "atilioned(sancyter1)",
        "atilioned(avirriced1)",
        "atilioned(iscolad1)",
        "atilioned(urafflag1)",
        "rapicary(shemood1)",
        "rapicary(bintioust1)",
        "aurpher(torifism1)",
        "chlectic(shemood1)",
        "llike(retritt1)",
        "exit(rofflum1,iciante1)",
        "exit(iciante1,rofflum1)",
        "exit(llism1,iciante1)",
        "exit(realighy1,rofflum1)",
        "exit(rofflum1,realighy1)",
        "exit(iciante1,llism1)",
        "serhing_able(forotoly1)",
        "serhing_able(harantal1)",
        "serhing_able(bintioust1)",
        "serhing_able(urafflag1)",
        "serhing_able(retritt1)",
        "serhing_able(sancyter1)",
        "atilioned_able(bintioust1)",
        "atilioned_able(shemood1)",
        "atilioned_able(urafflag1)",
        "atilioned_able(iscolad1)",
        "atilioned_able(avirriced1)",
        "atilioned_able(sancyter1)",
        "aurpher_able(shemood1)",
        "aurpher_able(retritt1)",
        "aurpher_able(torifism1)"
      ],
      "goal_state": [
        "serhing(forotoly1)",
        "atilioned(bintioust1)",
        "aurpher(retritt1)"
      ],
      "optimal_turns": 6,
      "optimal_solution": [
        [
          "ntion",
          "forotoly1"
        ],
        [
          "phinding",
          "retritt1"
        ],
        [
          "go",
          "rofflum1"
        ],
        [
          "go",
          "iciante1"
        ],
        [
          "go",
          "llism1"
        ],
        [
          "eoster",
          "bintioust1"
        ]
      ],
      "optimal_commands": [
        "ntion forotoly",
        "phinding retritt",
        "go rofflum",
        "go iciante",
        "go llism",
        "eoster bintioust"
      ],
      "action_definitions": [
        {
          "lark": "ntion: NTION thing\nNTION.1: \"ntion\" WS",
          "pddl": "(:action NTION\n    :parameters (?e - serhing_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (serhing ?e)\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not serhing-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now serhing.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To ntion is to make something serhing_able serhing.",
          "asp": "{ action_t(TURN,ntion,THING):at_t(TURN,THING,ROOM),serhing_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nserhing_t(TURN+1,THING) :- action_t(TURN,ntion,THING).\nserhing_t(TURN+1,THING) :- turn(TURN), serhing_t(TURN,THING).",
          "type_name": "ntion"
        },
        {
          "lark": "anumman: ANUMMAN thing\nANUMMAN.1: \"anumman\" WS",
          "pddl": "(:action ANUMMAN\n    :parameters (?e - atilioned_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (atilioned ?e)\n        )\n    :effect (and\n        (rapicary ?e)\n        (not (atilioned ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not atilioned-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not atilioned.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now rapicary.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To anumman is to make something atilioned_able and atilioned be rapicary.",
          "asp": "{ action_t(TURN,anumman,THING):at_t(TURN,THING,ROOM),atilioned_able(THING),atilioned_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nrapicary_t(TURN+1,THING) :- action_t(TURN,anumman,THING).\natilioned_t(TURN+1,THING) :- turn(TURN), atilioned_t(TURN,THING), not action_t(TURN,anumman,THING).",
          "type_name": "anumman"
        },
        {
          "lark": "eoster: EOSTER thing\nEOSTER.1: \"eoster\" WS",
          "pddl": "(:action EOSTER\n    :parameters (?e - atilioned_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (rapicary ?e)\n        )\n    :effect (and\n        (atilioned ?e)\n        (not (rapicary ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not atilioned-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not rapicary.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now atilioned.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To eoster is to make something atilioned_able and rapicary be atilioned.",
          "asp": "{ action_t(TURN,eoster,THING):at_t(TURN,THING,ROOM),atilioned_able(THING),rapicary_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\natilioned_t(TURN+1,THING) :- action_t(TURN,eoster,THING).\nrapicary_t(TURN+1,THING) :- turn(TURN), rapicary_t(TURN,THING), not action_t(TURN,eoster,THING).",
          "type_name": "eoster"
        },
        {
          "lark": "llatic: LLATIC thing\nLLATIC.1: \"llatic\" WS",
          "pddl": "(:action LLATIC\n    :parameters (?e - aurpher_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (aurpher ?e)\n        )\n    :effect (and\n        (chlectic ?e)\n        (not (aurpher ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not aurpher-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not aurpher.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now chlectic.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To llatic is to make something aurpher_able and aurpher be chlectic.",
          "asp": "{ action_t(TURN,llatic,THING):at_t(TURN,THING,ROOM),aurpher_able(THING),aurpher_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nchlectic_t(TURN+1,THING) :- action_t(TURN,llatic,THING).\naurpher_t(TURN+1,THING) :- turn(TURN), aurpher_t(TURN,THING), not action_t(TURN,llatic,THING).",
          "type_name": "llatic"
        },
        {
          "lark": "cumative: CUMATIVE thing\nCUMATIVE.1: \"cumative\" WS",
          "pddl": "(:action CUMATIVE\n    :parameters (?e - aurpher_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (chlectic ?e)\n        )\n    :effect (and\n        (llike ?e)\n        (not (chlectic ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not aurpher-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not chlectic.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now llike.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To cumative is to make something aurpher_able and chlectic be llike.",
          "asp": "{ action_t(TURN,cumative,THING):at_t(TURN,THING,ROOM),aurpher_able(THING),chlectic_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nllike_t(TURN+1,THING) :- action_t(TURN,cumative,THING).\nchlectic_t(TURN+1,THING) :- turn(TURN), chlectic_t(TURN,THING), not action_t(TURN,cumative,THING).",
          "type_name": "cumative"
        },
        {
          "lark": "phinding: PHINDING thing\nPHINDING.1: \"phinding\" WS",
          "pddl": "(:action PHINDING\n    :parameters (?e - aurpher_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (llike ?e)\n        )\n    :effect (and\n        (aurpher ?e)\n        (not (llike ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not aurpher-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not llike.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now aurpher.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To phinding is to make something aurpher_able and llike be aurpher.",
          "asp": "{ action_t(TURN,phinding,THING):at_t(TURN,THING,ROOM),aurpher_able(THING),llike_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\naurpher_t(TURN+1,THING) :- action_t(TURN,phinding,THING).\nllike_t(TURN+1,THING) :- turn(TURN), llike_t(TURN,THING), not action_t(TURN,phinding,THING).",
          "type_name": "phinding"
        },
        {
          "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
          "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
          "pddl_parameter_mapping": {
            "?c": [
              "current_player_room"
            ],
            "?d": [
              "arg1"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ c }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ d }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't go to a {{ d }} from here.",
                "no_exit_to"
              ],
              [
                "You are already in the {{ d }}.",
                "going_to_current_room"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
          "epistemic": true,
          "pragmatic": true,
          "explanation": "To VERB is to move through space, especially to a place.",
          "type_name": "go"
        },
        {
          "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
          "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "You consider yourself done.",
          "asp": "",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To VERB is to end the game.",
          "type_name": "done"
        },
        {
          "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ],
            "?e": [
              "arg1"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ e }} is not an entity. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "Your inventory is not an entity. (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "{{ arg1_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to observe or inspect carefully.",
          "type_name": "examine"
        },
        {
          "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to inspect a room.",
          "type_name": "look"
        }
      ],
      "room_definitions": [
        {
          "repr_str": "rofflum",
          "exit_targets": [
            "llism",
            "iciante"
          ],
          "max_connections": 1,
          "type_name": "rofflum"
        },
        {
          "repr_str": "iciante",
          "exit_targets": [
            "rofflum"
          ],
          "max_connections": 3,
          "type_name": "iciante"
        },
        {
          "repr_str": "llism",
          "exit_targets": [
            "iciante",
            "realighy"
          ],
          "max_connections": 2,
          "type_name": "llism"
        },
        {
          "repr_str": "realighy",
          "exit_targets": [
            "llism",
            "iciante",
            "rofflum"
          ],
          "max_connections": 2,
          "type_name": "realighy"
        }
      ],
      "entity_definitions": [
        {
          "repr_str": "forotoly",
          "traits": [
            "serhing_able"
          ],
          "standard_locations": [
            "iciante",
            "realighy"
          ],
          "type_name": "forotoly"
        },
        {
          "repr_str": "harantal",
          "traits": [
            "serhing_able"
          ],
          "standard_locations": [
            "rofflum"
          ],
          "type_name": "harantal"
        },
        {
          "repr_str": "bintioust",
          "traits": [
            "atilioned_able",
            "serhing_able"
          ],
          "standard_locations": [
            "realighy",
            "llism"
          ],
          "type_name": "bintioust"
        },
        {
          "repr_str": "shemood",
          "traits": [
            "atilioned_able",
            "aurpher_able"
          ],
          "standard_locations": [
            "realighy"
          ],
          "type_name": "shemood"
        },
        {
          "repr_str": "urafflag",
          "traits": [
            "atilioned_able",
            "serhing_able"
          ],
          "standard_locations": [
            "realighy",
            "iciante"
          ],
          "type_name": "urafflag"
        },
        {
          "repr_str": "iscolad",
          "traits": [
            "atilioned_able"
          ],
          "standard_locations": [
            "rofflum",
            "realighy"
          ],
          "type_name": "iscolad"
        },
        {
          "repr_str": "avirriced",
          "traits": [
            "atilioned_able"
          ],
          "standard_locations": [
            "realighy"
          ],
          "type_name": "avirriced"
        },
        {
          "repr_str": "retritt",
          "traits": [
            "aurpher_able",
            "serhing_able"
          ],
          "standard_locations": [
            "realighy"
          ],
          "type_name": "retritt"
        },
        {
          "repr_str": "sancyter",
          "traits": [
            "serhing_able",
            "atilioned_able"
          ],
          "standard_locations": [
            "iciante"
          ],
          "type_name": "sancyter"
        },
        {
          "repr_str": "torifism",
          "traits": [
            "aurpher_able"
          ],
          "standard_locations": [
            "rofflum",
            "llism"
          ],
          "type_name": "torifism"
        },
        {
          "repr_str": "you",
          "traits": [],
          "hidden": true,
          "type_name": "player"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "inventory"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "floor"
        }
      ],
      "domain_definitions": [
        {
          "domain_id": "new_words",
          "types": {
            "room": [
              "rofflum",
              "iciante",
              "llism",
              "realighy"
            ],
            "entity": [
              "player",
              "inventory",
              "floor",
              "forotoly",
              "harantal",
              "bintioust",
              "shemood",
              "urafflag",
              "iscolad",
              "avirriced",
              "retritt",
              "sancyter",
              "torifism",
              "player",
              "inventory",
              "floor"
            ],
            "serhing_able": [
              "forotoly",
              "harantal",
              "bintioust",
              "urafflag",
              "retritt",
              "sancyter"
            ],
            "atilioned_able": [
              "bintioust",
              "shemood",
              "urafflag",
              "iscolad",
              "avirriced",
              "sancyter"
            ],
            "aurpher_able": [
              "shemood",
              "retritt",
              "torifism"
            ]
          },
          "predicates": [
            {
              "predicate_id": "serhing",
              "variable": "e",
              "mutability": "serhing_able"
            },
            {
              "predicate_id": "atilioned",
              "variable": "e",
              "mutability": "atilioned_able"
            },
            {
              "predicate_id": "rapicary",
              "variable": "e",
              "mutability": "atilioned_able"
            },
            {
              "predicate_id": "aurpher",
              "variable": "e",
              "mutability": "aurpher_able"
            },
            {
              "predicate_id": "chlectic",
              "variable": "e",
              "mutability": "aurpher_able"
            },
            {
              "predicate_id": "llike",
              "variable": "e",
              "mutability": "aurpher_able"
            }
          ]
        }
      ],
      "bench_turn_limit": 50,
      "prompt_template_set": "new-words_created"
    },
    {
      "adventure_type": "new-words_created",
      "goal": "Make the telyphy vatmene, the rogisart pineger and the pienthor exabarb.",
      "initial_state": [
        "at(ansubder1,gurlite1)",
        "at(hocyard1,puranity1)",
        "at(rogisart1,caligaticed1)",
        "at(pakably1,caligaticed1)",
        "at(tecural1,caligaticed1)",
        "at(ubdonee1,caligaticed1)",
        "at(aribess1,caligaticed1)",
        "at(telyphy1,redaka1)",
        "at(cophaal1,gurlite1)",
        "at(pienthor1,caligaticed1)",
        "at(player1,caligaticed1)",
        "type(player1,player)",
        "type(pienthor1,pienthor)",
        "type(cophaal1,cophaal)",
        "type(telyphy1,telyphy)",
        "type(aribess1,aribess)",
        "type(ubdonee1,ubdonee)",
        "type(tecural1,tecural)",
        "type(pakably1,pakably)",
        "type(rogisart1,rogisart)",
        "type(hocyard1,hocyard)",
        "type(ansubder1,ansubder)",
        "room(gurlite1,gurlite)",
        "room(puranity1,puranity)",
        "room(redaka1,redaka)",
        "room(caligaticed1,caligaticed)",
        "vatmene(hocyard1)",
        "vatmene(pakably1)",
        "vatmene(tecural1)",
        "vatmene(ubdonee1)",
        "ioblex(aribess1)",
        "ioblex(telyphy1)",
        "pineger(ansubder1)",
        "earatory(aribess1)",
        "onesive(rogisart1)",
        "exit(gurlite1,puranity1)",
        "exit(puranity1,gurlite1)",
        "exit(redaka1,puranity1)",
        "exit(caligaticed1,gurlite1)",
        "exit(gurlite1,caligaticed1)",
        "exit(puranity1,redaka1)",
        "exabarb_able(pienthor1)",
        "exabarb_able(cophaal1)",
        "exabarb_able(telyphy1)",
        "exabarb_able(ubdonee1)",
        "exabarb_able(rogisart1)",
        "exabarb_able(hocyard1)",
        "vatmene_able(telyphy1)",
        "vatmene_able(aribess1)",
        "vatmene_able(ubdonee1)",
        "vatmene_able(tecural1)",
        "vatmene_able(pakably1)",
        "vatmene_able(hocyard1)",
        "pineger_able(aribess1)",
        "pineger_able(rogisart1)",
        "pineger_able(ansubder1)"
      ],
      "goal_state": [
        "exabarb(pienthor1)",
        "vatmene(telyphy1)",
        "pineger(rogisart1)"
      ],
      "optimal_turns": 6,
      "optimal_solution": [
        [
          "lystly",
          "pienthor1"
        ],
        [
          "tationnis",
          "rogisart1"
        ],
        [
          "go",
          "gurlite1"
        ],
        [
          "go",
          "puranity1"
        ],
        [
          "go",
          "redaka1"
        ],
        [
          "prophedly",
          "telyphy1"
        ]
      ],
      "optimal_commands": [
        "lystly pienthor",
        "tationnis rogisart",
        "go gurlite",
        "go puranity",
        "go redaka",
        "prophedly telyphy"
      ],
      "action_definitions": [
        {
          "lark": "lystly: LYSTLY thing\nLYSTLY.1: \"lystly\" WS",
          "pddl": "(:action LYSTLY\n    :parameters (?e - exabarb_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n)\n    :effect (and\n        (exabarb ?e)\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not exabarb-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now exabarb.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To lystly is to make something exabarb_able exabarb.",
          "asp": "{ action_t(TURN,lystly,THING):at_t(TURN,THING,ROOM),exabarb_able(THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nexabarb_t(TURN+1,THING) :- action_t(TURN,lystly,THING).\nexabarb_t(TURN+1,THING) :- turn(TURN), exabarb_t(TURN,THING).",
          "type_name": "lystly"
        },
        {
          "lark": "sifoat: SIFOAT thing\nSIFOAT.1: \"sifoat\" WS",
          "pddl": "(:action SIFOAT\n    :parameters (?e - vatmene_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (vatmene ?e)\n        )\n    :effect (and\n        (ioblex ?e)\n        (not (vatmene ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not vatmene-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not vatmene.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now ioblex.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To sifoat is to make something vatmene_able and vatmene be ioblex.",
          "asp": "{ action_t(TURN,sifoat,THING):at_t(TURN,THING,ROOM),vatmene_able(THING),vatmene_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nioblex_t(TURN+1,THING) :- action_t(TURN,sifoat,THING).\nvatmene_t(TURN+1,THING) :- turn(TURN), vatmene_t(TURN,THING), not action_t(TURN,sifoat,THING).",
          "type_name": "sifoat"
        },
        {
          "lark": "prophedly: PROPHEDLY thing\nPROPHEDLY.1: \"prophedly\" WS",
          "pddl": "(:action PROPHEDLY\n    :parameters (?e - vatmene_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (ioblex ?e)\n        )\n    :effect (and\n        (vatmene ?e)\n        (not (ioblex ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not vatmene-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not ioblex.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now vatmene.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To prophedly is to make something vatmene_able and ioblex be vatmene.",
          "asp": "{ action_t(TURN,prophedly,THING):at_t(TURN,THING,ROOM),vatmene_able(THING),ioblex_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nvatmene_t(TURN+1,THING) :- action_t(TURN,prophedly,THING).\nioblex_t(TURN+1,THING) :- turn(TURN), ioblex_t(TURN,THING), not action_t(TURN,prophedly,THING).",
          "type_name": "prophedly"
        },
        {
          "lark": "curatily: CURATILY thing\nCURATILY.1: \"curatily\" WS",
          "pddl": "(:action CURATILY\n    :parameters (?e - pineger_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (pineger ?e)\n        )\n    :effect (and\n        (earatory ?e)\n        (not (pineger ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not pineger-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not pineger.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now earatory.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To curatily is to make something pineger_able and pineger be earatory.",
          "asp": "{ action_t(TURN,curatily,THING):at_t(TURN,THING,ROOM),pineger_able(THING),pineger_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nearatory_t(TURN+1,THING) :- action_t(TURN,curatily,THING).\npineger_t(TURN+1,THING) :- turn(TURN), pineger_t(TURN,THING), not action_t(TURN,curatily,THING).",
          "type_name": "curatily"
        },
        {
          "lark": "uncomagol: UNCOMAGOL thing\nUNCOMAGOL.1: \"uncomagol\" WS",
          "pddl": "(:action UNCOMAGOL\n    :parameters (?e - pineger_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (earatory ?e)\n        )\n    :effect (and\n        (onesive ?e)\n        (not (earatory ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not pineger-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not earatory.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now onesive.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To uncomagol is to make something pineger_able and earatory be onesive.",
          "asp": "{ action_t(TURN,uncomagol,THING):at_t(TURN,THING,ROOM),pineger_able(THING),earatory_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nonesive_t(TURN+1,THING) :- action_t(TURN,uncomagol,THING).\nearatory_t(TURN+1,THING) :- turn(TURN), earatory_t(TURN,THING), not action_t(TURN,uncomagol,THING).",
          "type_name": "uncomagol"
        },
        {
          "lark": "tationnis: TATIONNIS thing\nTATIONNIS.1: \"tationnis\" WS",
          "pddl": "(:action TATIONNIS\n    :parameters (?e - pineger_able ?r - room ?p - player)\n    :precondition (and\n        (at ?p ?r)\n        (at ?e ?r)\n        (onesive ?e)\n        )\n    :effect (and\n        (pineger ?e)\n        (not (onesive ?e))\n    )\n)",
          "pddl_parameter_mapping": {
            "?e": [
              "arg1"
            ],
            "?r": [
              "current_player_room"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "The {{ e }} is not pineger-able.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "The {{ e }} is not onesive.",
                "entity_state_mismatch"
              ]
            ]
          },
          "success_feedback": "The {{ e }} is now pineger.",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To tationnis is to make something pineger_able and onesive be pineger.",
          "asp": "{ action_t(TURN,tationnis,THING):at_t(TURN,THING,ROOM),pineger_able(THING),onesive_t(TURN,THING) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\npineger_t(TURN+1,THING) :- action_t(TURN,tationnis,THING).\nonesive_t(TURN+1,THING) :- turn(TURN), onesive_t(TURN,THING), not action_t(TURN,tationnis,THING).",
          "type_name": "tationnis"
        },
        {
          "lark": "go: GO (\"back\" WS)* (\"to\" WS)* thing\nGO.1: (\"go\" | \"enter\" | \"return\" | \"proceed\" | \"move\") WS",
          "pddl": "(:action GO\n    :parameters (?c ?d - room ?p - player)\n    :precondition (and\n        (at ?p ?c)\n        (exit ?c ?d)\n        (not (at ?p ?d))\n        )\n    :effect (and\n        (at ?p ?d)\n        (not (at ?p ?c))\n    )\n)",
          "pddl_parameter_mapping": {
            "?c": [
              "current_player_room"
            ],
            "?d": [
              "arg1"
            ],
            "?p": [
              "player"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ c }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ d }} is not a room.",
                "domain_trait_type_mismatch"
              ],
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't go to a {{ d }} from here.",
                "no_exit_to"
              ],
              [
                "You are already in the {{ d }}.",
                "going_to_current_room"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "{ action_t(TURN,go,TARGET):exit(ROOM,TARGET) } 1 :- turn(TURN), at_t(TURN,player1,ROOM), not turn_limit(TURN).\nat_t(TURN+1,player1,TARGET) :- action_t(TURN,go,TARGET).\nat_t(TURN+1,player1,ROOM) :- turn(TURN), at_t(TURN,player1,ROOM), not action_t(TURN,go,_).\nat_t(TURN+1,THING,ROOM) :- turn(TURN), at_t(TURN,THING,ROOM), not THING = player1.",
          "epistemic": true,
          "pragmatic": true,
          "explanation": "To VERB is to move through space, especially to a place.",
          "type_name": "go"
        },
        {
          "lark": "done: DONE\nDONE.1: (\"done\" | \"quit\" | \"finish\") WS*",
          "pddl": "(:action DONE\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n        )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "You consider yourself done.",
          "asp": "",
          "epistemic": false,
          "pragmatic": true,
          "explanation": "To VERB is to end the game.",
          "type_name": "done"
        },
        {
          "lark": "examine: EXAMINE thing\nEXAMINE.1: (\"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action EXAMINE\n    :parameters (?p - player ?r - room ?e - entity)\n    :precondition (and\n        (at ?p ?r)\n        (or\n            (at ?e ?r)\n            (type ?e inventory)\n            )\n        (accessible ?e)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ],
            "?e": [
              "arg1"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ e }} is not an entity. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ],
              [
                "Your inventory is not an entity. (This should not occur.)",
                "world_state_discrepancy"
              ],
              [
                "You can't see a {{ e }} here.",
                "entity_not_accessible"
              ]
            ]
          },
          "success_feedback": "{{ arg1_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to observe or inspect carefully.",
          "type_name": "examine"
        },
        {
          "lark": "look: LOOK (\"at\"* ( thing | \"around\" | \"room\" ) )\nLOOK.1: (\"look\" | \"examine\" | \"check\" | \"inspect\" | \"search\") WS",
          "pddl": "(:action LOOK\n    :parameters (?p - player ?r - room)\n    :precondition (and\n        (at ?p ?r)\n            )\n    :effect (and\n    )\n)",
          "pddl_parameter_mapping": {
            "?p": [
              "player"
            ],
            "?r": [
              "current_player_room"
            ]
          },
          "failure_feedback": {
            "parameters": [
              [
                "{{ p }} is not a player. (This should not occur.)",
                "domain_type_discrepancy"
              ],
              [
                "{{ r }} is not a room. (This should not occur.)",
                "domain_type_discrepancy"
              ]
            ],
            "precondition": [
              [
                "You are not where you are! (This should not occur.)",
                "world_state_discrepancy"
              ]
            ]
          },
          "success_feedback": "{{ room_desc }}",
          "asp": "",
          "epistemic": true,
          "pragmatic": false,
          "explanation": "To VERB is to inspect a room.",
          "type_name": "look"
        }
      ],
      "room_definitions": [
        {
          "repr_str": "gurlite",
          "exit_targets": [
            "redaka",
            "puranity"
          ],
          "max_connections": 1,
          "type_name": "gurlite"
        },
        {
          "repr_str": "puranity",
          "exit_targets": [
            "gurlite"
          ],
          "max_connections": 3,
          "type_name": "puranity"
        },
        {
          "repr_str": "redaka",
          "exit_targets": [
            "puranity",
            "caligaticed"
          ],
          "max_connections": 2,
          "type_name": "redaka"
        },
        {
          "repr_str": "caligaticed",
          "exit_targets": [
            "redaka",
            "puranity",
            "gurlite"
          ],
          "max_connections": 2,
          "type_name": "caligaticed"
        }
      ],
      "entity_definitions": [
        {
          "repr_str": "pienthor",
          "traits": [
            "exabarb_able"
          ],
          "standard_locations": [
            "puranity",
            "caligaticed"
          ],
          "type_name": "pienthor"
        },
        {
          "repr_str": "cophaal",
          "traits": [
            "exabarb_able"
          ],
          "standard_locations": [
            "gurlite"
          ],
          "type_name": "cophaal"
        },
        {
          "repr_str": "telyphy",
          "traits": [
            "vatmene_able",
            "exabarb_able"
          ],
          "standard_locations": [
            "caligaticed",
            "redaka"
          ],
          "type_name": "telyphy"
        },
        {
          "repr_str": "aribess",
          "traits": [
            "vatmene_able",
            "pineger_able"
          ],
          "standard_locations": [
            "caligaticed"
          ],
          "type_name": "aribess"
        },
        {
          "repr_str": "ubdonee",
          "traits": [
            "vatmene_able",
            "exabarb_able"
          ],
          "standard_locations": [
            "caligaticed",
            "puranity"
          ],
          "type_name": "ubdonee"
        },
        {
          "repr_str": "tecural",
          "traits": [
            "vatmene_able"
          ],
          "standard_locations": [
            "gurlite",
            "caligaticed"
          ],
          "type_name": "tecural"
        },
        {
          "repr_str": "pakably",
          "traits": [
            "vatmene_able"
          ],
          "standard_locations": [
            "caligaticed"
          ],
          "type_name": "pakably"
        },
        {
          "repr_str": "rogisart",
          "traits": [
            "pineger_able",
            "exabarb_able"
          ],
          "standard_locations": [
            "caligaticed"
          ],
          "type_name": "rogisart"
        },
        {
          "repr_str": "hocyard",
          "traits": [
            "exabarb_able",
            "vatmene_able"
          ],
          "standard_locations": [
            "puranity"
          ],
          "type_name": "hocyard"
        },
        {
          "repr_str": "ansubder",
          "traits": [
            "pineger_able"
          ],
          "standard_locations": [
            "gurlite",
            "redaka"
          ],
          "type_name": "ansubder"
        },
        {
          "repr_str": "you",
          "traits": [],
          "hidden": true,
          "type_name": "player"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "inventory"
        },
        {
          "repr_str": "",
          "traits": [],
          "hidden": true,
          "type_name": "floor"
        }
      ],
      "domain_definitions": [
        {
          "domain_id": "new_words",
          "types": {
            "room": [
              "gurlite",
              "puranity",
              "redaka",
              "caligaticed"
            ],
            "entity": [
              "player",
              "inventory",
              "floor",
              "pienthor",
              "cophaal",
              "telyphy",
              "aribess",
              "ubdonee",
              "tecural",
              "pakably",
              "rogisart",
              "hocyard",
              "ansubder",
              "player",
              "inventory",
              "floor"
            ],
            "exabarb_able": [
              "pienthor",
              "cophaal",
              "telyphy",
              "ubdonee",
              "rogisart",
              "hocyard"
            ],
            "vatmene_able": [
              "telyphy",
              "aribess",
              "ubdonee",
              "tecural",
              "pakably",
              "hocyard"
            ],
            "pineger_able": [
              "aribess",
              "rogisart",
              "ansubder"
            ]
          },
          "predicates": [
            {
              "predicate_id": "exabarb",
              "variable": "e",
              "mutability": "exabarb_able"
            },
            {
              "predicate_id": "vatmene",
              "variable": "e",
              "mutability": "vatmene_able"
            },
            {
              "predicate_id": "ioblex",
              "variable": "e",
              "mutability": "vatmene_able"
            },
            {
              "predicate_id": "pineger",
              "variable": "e",
              "mutability": "pineger_able"
            },
            {
              "predicate_id": "earatory",
              "variable": "e",
              "mutability": "pineger_able"
            },
            {
              "predicate_id": "onesive",
              "variable": "e",
              "mutability": "pineger_able"
            }
          ]
        }
      ],
      "bench_turn_limit": 50,
      "prompt_template_set": "new-words_created"
    }
  ]
}